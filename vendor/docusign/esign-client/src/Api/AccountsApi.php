<?php
/**
 * AccountsApi
 * PHP version 5
 *
 * @category Class
 * @package  DocuSign\eSign
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * DocuSign REST API
 *
 * The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.
 *
 * OpenAPI spec version: v2.1
 * Contact: devcenter@docusign.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.13-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace DocuSign\eSign\Api\AccountsApi;

class CreateOptions
{
    /**
      * $preview_billing_plan When set to **true**, creates the account using a preview billing plan.
      * @var string
      */
    protected $preview_billing_plan;

    /**
     * Gets preview_billing_plan
     * @return string
     */
    public function getPreviewBillingPlan()
    {
        return $this->preview_billing_plan;
    }
  
    /**
     * Sets preview_billing_plan
     * @param string $preview_billing_plan When set to **true**, creates the account using a preview billing plan.
     * @return $this
     */
    public function setPreviewBillingPlan($preview_billing_plan)
    {
        $this->preview_billing_plan = $preview_billing_plan;
        return $this;
    }
}
class CreateAccountSignaturesOptions
{
    /**
      * $decode_only 
      * @var string
      */
    protected $decode_only;

    /**
     * Gets decode_only
     * @return string
     */
    public function getDecodeOnly()
    {
        return $this->decode_only;
    }
  
    /**
     * Sets decode_only
     * @param string $decode_only 
     * @return $this
     */
    public function setDecodeOnly($decode_only)
    {
        $this->decode_only = $decode_only;
        return $this;
    }
}
class CreateCustomFieldOptions
{
    /**
      * $apply_to_templates 
      * @var string
      */
    protected $apply_to_templates;

    /**
     * Gets apply_to_templates
     * @return string
     */
    public function getApplyToTemplates()
    {
        return $this->apply_to_templates;
    }
  
    /**
     * Sets apply_to_templates
     * @param string $apply_to_templates 
     * @return $this
     */
    public function setApplyToTemplates($apply_to_templates)
    {
        $this->apply_to_templates = $apply_to_templates;
        return $this;
    }
}
class CreatePermissionProfileOptions
{
    /**
      * $include 
      * @var string
      */
    protected $include;

    /**
     * Gets include
     * @return string
     */
    public function getInclude()
    {
        return $this->include;
    }
  
    /**
     * Sets include
     * @param string $include 
     * @return $this
     */
    public function setInclude($include)
    {
        $this->include = $include;
        return $this;
    }
}
class DeleteCustomFieldOptions
{
    /**
      * $apply_to_templates 
      * @var string
      */
    protected $apply_to_templates;

    /**
     * Gets apply_to_templates
     * @return string
     */
    public function getApplyToTemplates()
    {
        return $this->apply_to_templates;
    }
  
    /**
     * Sets apply_to_templates
     * @param string $apply_to_templates 
     * @return $this
     */
    public function setApplyToTemplates($apply_to_templates)
    {
        $this->apply_to_templates = $apply_to_templates;
        return $this;
    }
}
class DeletePermissionProfileOptions
{
    /**
      * $move_users_to 
      * @var string
      */
    protected $move_users_to;

    /**
     * Gets move_users_to
     * @return string
     */
    public function getMoveUsersTo()
    {
        return $this->move_users_to;
    }
  
    /**
     * Sets move_users_to
     * @param string $move_users_to 
     * @return $this
     */
    public function setMoveUsersTo($move_users_to)
    {
        $this->move_users_to = $move_users_to;
        return $this;
    }
}
class GetAccountInformationOptions
{
    /**
      * $include_account_settings When set to **true**, includes the account settings for the account in the response.
      * @var string
      */
    protected $include_account_settings;

    /**
     * Gets include_account_settings
     * @return string
     */
    public function getIncludeAccountSettings()
    {
        return $this->include_account_settings;
    }
  
    /**
     * Sets include_account_settings
     * @param string $include_account_settings When set to **true**, includes the account settings for the account in the response.
     * @return $this
     */
    public function setIncludeAccountSettings($include_account_settings)
    {
        $this->include_account_settings = $include_account_settings;
        return $this;
    }
}
class GetAccountSignatureImageOptions
{
    /**
      * $include_chrome 
      * @var string
      */
    protected $include_chrome;

    /**
     * Gets include_chrome
     * @return string
     */
    public function getIncludeChrome()
    {
        return $this->include_chrome;
    }
  
    /**
     * Sets include_chrome
     * @param string $include_chrome 
     * @return $this
     */
    public function setIncludeChrome($include_chrome)
    {
        $this->include_chrome = $include_chrome;
        return $this;
    }
}
class GetAccountSignaturesOptions
{
    /**
      * $stamp_format 
      * @var string
      */
    protected $stamp_format;

    /**
     * Gets stamp_format
     * @return string
     */
    public function getStampFormat()
    {
        return $this->stamp_format;
    }
  
    /**
     * Sets stamp_format
     * @param string $stamp_format 
     * @return $this
     */
    public function setStampFormat($stamp_format)
    {
        $this->stamp_format = $stamp_format;
        return $this;
    }
    /**
      * $stamp_name 
      * @var string
      */
    protected $stamp_name;

    /**
     * Gets stamp_name
     * @return string
     */
    public function getStampName()
    {
        return $this->stamp_name;
    }
  
    /**
     * Sets stamp_name
     * @param string $stamp_name 
     * @return $this
     */
    public function setStampName($stamp_name)
    {
        $this->stamp_name = $stamp_name;
        return $this;
    }
    /**
      * $stamp_type 
      * @var string
      */
    protected $stamp_type;

    /**
     * Gets stamp_type
     * @return string
     */
    public function getStampType()
    {
        return $this->stamp_type;
    }
  
    /**
     * Sets stamp_type
     * @param string $stamp_type 
     * @return $this
     */
    public function setStampType($stamp_type)
    {
        $this->stamp_type = $stamp_type;
        return $this;
    }
}
class GetBillingChargesOptions
{
    /**
      * $include_charges Specifies which billing charges to return. Valid values are:  * envelopes * seats
      * @var string
      */
    protected $include_charges;

    /**
     * Gets include_charges
     * @return string
     */
    public function getIncludeCharges()
    {
        return $this->include_charges;
    }
  
    /**
     * Sets include_charges
     * @param string $include_charges Specifies which billing charges to return. Valid values are:  * envelopes * seats
     * @return $this
     */
    public function setIncludeCharges($include_charges)
    {
        $this->include_charges = $include_charges;
        return $this;
    }
}
class GetBrandOptions
{
    /**
      * $include_external_references 
      * @var string
      */
    protected $include_external_references;

    /**
     * Gets include_external_references
     * @return string
     */
    public function getIncludeExternalReferences()
    {
        return $this->include_external_references;
    }
  
    /**
     * Sets include_external_references
     * @param string $include_external_references 
     * @return $this
     */
    public function setIncludeExternalReferences($include_external_references)
    {
        $this->include_external_references = $include_external_references;
        return $this;
    }
    /**
      * $include_logos 
      * @var string
      */
    protected $include_logos;

    /**
     * Gets include_logos
     * @return string
     */
    public function getIncludeLogos()
    {
        return $this->include_logos;
    }
  
    /**
     * Sets include_logos
     * @param string $include_logos 
     * @return $this
     */
    public function setIncludeLogos($include_logos)
    {
        $this->include_logos = $include_logos;
        return $this;
    }
}
class GetBrandResourcesByContentTypeOptions
{
    /**
      * $langcode 
      * @var string
      */
    protected $langcode;

    /**
     * Gets langcode
     * @return string
     */
    public function getLangcode()
    {
        return $this->langcode;
    }
  
    /**
     * Sets langcode
     * @param string $langcode 
     * @return $this
     */
    public function setLangcode($langcode)
    {
        $this->langcode = $langcode;
        return $this;
    }
    /**
      * $return_master 
      * @var string
      */
    protected $return_master;

    /**
     * Gets return_master
     * @return string
     */
    public function getReturnMaster()
    {
        return $this->return_master;
    }
  
    /**
     * Sets return_master
     * @param string $return_master 
     * @return $this
     */
    public function setReturnMaster($return_master)
    {
        $this->return_master = $return_master;
        return $this;
    }
}
class GetConsumerDisclosureDefaultOptions
{
    /**
      * $lang_code Specifies the language used in the response. The supported languages, with the language value shown in parenthesis, are: Arabic (ar), Armenian (hy), Bulgarian (bg), Czech (cs), Chinese Simplified (zh_CN), Chinese Traditional (zh_TW), Croatian (hr), Danish (da), Dutch (nl), English US (en), English UK (en_GB), Estonian (et), Farsi (fa), Finnish (fi), French (fr), French Canada (fr_CA), German (de), Greek (el), Hebrew (he), Hindi (hi), Hungarian (hu), Bahasa Indonesia (id), Italian (it), Japanese (ja), Korean (ko), Latvian (lv), Lithuanian (lt), Bahasa Melayu (ms), Norwegian (no), Polish (pl), Portuguese (pt), Portuguese Brazil (pt_BR), Romanian (ro), Russian (ru), Serbian (sr), Slovak (sk), Slovenian (sl), Spanish (es),Spanish Latin America (es_MX), Swedish (sv), Thai (th), Turkish (tr), Ukrainian (uk), and Vietnamese (vi).  Additionally, the value can be set to `browser` to automatically detect the browser language being used by the viewer and display the disclosure in that language.
      * @var string
      */
    protected $lang_code;

    /**
     * Gets lang_code
     * @return string
     */
    public function getLangCode()
    {
        return $this->lang_code;
    }
  
    /**
     * Sets lang_code
     * @param string $lang_code Specifies the language used in the response. The supported languages, with the language value shown in parenthesis, are: Arabic (ar), Armenian (hy), Bulgarian (bg), Czech (cs), Chinese Simplified (zh_CN), Chinese Traditional (zh_TW), Croatian (hr), Danish (da), Dutch (nl), English US (en), English UK (en_GB), Estonian (et), Farsi (fa), Finnish (fi), French (fr), French Canada (fr_CA), German (de), Greek (el), Hebrew (he), Hindi (hi), Hungarian (hu), Bahasa Indonesia (id), Italian (it), Japanese (ja), Korean (ko), Latvian (lv), Lithuanian (lt), Bahasa Melayu (ms), Norwegian (no), Polish (pl), Portuguese (pt), Portuguese Brazil (pt_BR), Romanian (ro), Russian (ru), Serbian (sr), Slovak (sk), Slovenian (sl), Spanish (es),Spanish Latin America (es_MX), Swedish (sv), Thai (th), Turkish (tr), Ukrainian (uk), and Vietnamese (vi).  Additionally, the value can be set to `browser` to automatically detect the browser language being used by the viewer and display the disclosure in that language.
     * @return $this
     */
    public function setLangCode($lang_code)
    {
        $this->lang_code = $lang_code;
        return $this;
    }
}
class GetPermissionProfileOptions
{
    /**
      * $include 
      * @var string
      */
    protected $include;

    /**
     * Gets include
     * @return string
     */
    public function getInclude()
    {
        return $this->include;
    }
  
    /**
     * Sets include
     * @param string $include 
     * @return $this
     */
    public function setInclude($include)
    {
        $this->include = $include;
        return $this;
    }
}
class ListBrandsOptions
{
    /**
      * $exclude_distributor_brand When set to **true**, excludes distributor brand information from the response set.
      * @var string
      */
    protected $exclude_distributor_brand;

    /**
     * Gets exclude_distributor_brand
     * @return string
     */
    public function getExcludeDistributorBrand()
    {
        return $this->exclude_distributor_brand;
    }
  
    /**
     * Sets exclude_distributor_brand
     * @param string $exclude_distributor_brand When set to **true**, excludes distributor brand information from the response set.
     * @return $this
     */
    public function setExcludeDistributorBrand($exclude_distributor_brand)
    {
        $this->exclude_distributor_brand = $exclude_distributor_brand;
        return $this;
    }
    /**
      * $include_logos When set to **true**, returns the logos associated with the brand.
      * @var string
      */
    protected $include_logos;

    /**
     * Gets include_logos
     * @return string
     */
    public function getIncludeLogos()
    {
        return $this->include_logos;
    }
  
    /**
     * Sets include_logos
     * @param string $include_logos When set to **true**, returns the logos associated with the brand.
     * @return $this
     */
    public function setIncludeLogos($include_logos)
    {
        $this->include_logos = $include_logos;
        return $this;
    }
}
class ListPermissionsOptions
{
    /**
      * $include 
      * @var string
      */
    protected $include;

    /**
     * Gets include
     * @return string
     */
    public function getInclude()
    {
        return $this->include;
    }
  
    /**
     * Sets include
     * @param string $include 
     * @return $this
     */
    public function setInclude($include)
    {
        $this->include = $include;
        return $this;
    }
}
class ListRecipientNamesByEmailOptions
{
    /**
      * $email The email address for the user
      * @var string
      */
    protected $email;

    /**
     * Gets email
     * @return string
     */
    public function getEmail()
    {
        return $this->email;
    }
  
    /**
     * Sets email
     * @param string $email The email address for the user
     * @return $this
     */
    public function setEmail($email)
    {
        $this->email = $email;
        return $this;
    }
}
class ListSharedAccessOptions
{
    /**
      * $count Specifies maximum number of results included in the response. If no value is specified, this defaults to 1000.
      * @var string
      */
    protected $count;

    /**
     * Gets count
     * @return string
     */
    public function getCount()
    {
        return $this->count;
    }
  
    /**
     * Sets count
     * @param string $count Specifies maximum number of results included in the response. If no value is specified, this defaults to 1000.
     * @return $this
     */
    public function setCount($count)
    {
        $this->count = $count;
        return $this;
    }
    /**
      * $envelopes_not_shared_user_status 
      * @var string
      */
    protected $envelopes_not_shared_user_status;

    /**
     * Gets envelopes_not_shared_user_status
     * @return string
     */
    public function getEnvelopesNotSharedUserStatus()
    {
        return $this->envelopes_not_shared_user_status;
    }
  
    /**
     * Sets envelopes_not_shared_user_status
     * @param string $envelopes_not_shared_user_status 
     * @return $this
     */
    public function setEnvelopesNotSharedUserStatus($envelopes_not_shared_user_status)
    {
        $this->envelopes_not_shared_user_status = $envelopes_not_shared_user_status;
        return $this;
    }
    /**
      * $folder_ids 
      * @var string
      */
    protected $folder_ids;

    /**
     * Gets folder_ids
     * @return string
     */
    public function getFolderIds()
    {
        return $this->folder_ids;
    }
  
    /**
     * Sets folder_ids
     * @param string $folder_ids 
     * @return $this
     */
    public function setFolderIds($folder_ids)
    {
        $this->folder_ids = $folder_ids;
        return $this;
    }
    /**
      * $item_type Specifies the type of shared item being requested. The accepted values are: -envelopes: returns information about envelope sharing between users.
      * @var string
      */
    protected $item_type;

    /**
     * Gets item_type
     * @return string
     */
    public function getItemType()
    {
        return $this->item_type;
    }
  
    /**
     * Sets item_type
     * @param string $item_type Specifies the type of shared item being requested. The accepted values are: -envelopes: returns information about envelope sharing between users.
     * @return $this
     */
    public function setItemType($item_type)
    {
        $this->item_type = $item_type;
        return $this;
    }
    /**
      * $search_text This can be used to filter user names in the response. The wild-card '*' (asterisk) can be used around the string.
      * @var string
      */
    protected $search_text;

    /**
     * Gets search_text
     * @return string
     */
    public function getSearchText()
    {
        return $this->search_text;
    }
  
    /**
     * Sets search_text
     * @param string $search_text This can be used to filter user names in the response. The wild-card '*' (asterisk) can be used around the string.
     * @return $this
     */
    public function setSearchText($search_text)
    {
        $this->search_text = $search_text;
        return $this;
    }
    /**
      * $shared Specifies which users should be included in the response. Multiple values can be used in the query by using a comma separated list of shared values. If the requestor does not have account administrator privileges, the shared_to value is used. Requestors that do not have account administrator privileges can only use the shared_to, any other setting will result in an error. The accepted values are:  -not_shared: Returns account users that the specified item type is not being shared with and that are not sharing the specified item type with the user.  User X (Share) X Account user  -shared_to: Returns account users that the specified item type is not being shared with and who are sharing the specified item type with the user (only shared to the user).  User X (Share) Account user  -shared_from: Returns account users that the specified item type is being shared with and who are not sharing the specified item type with the user (only shared from the user).  User (Share) >> Account user  -shared_to_and_from: Returns account users that the specified item type is being shared with and who are sharing the specified item type with the user.  User << (Share) >> Account user
      * @var string
      */
    protected $shared;

    /**
     * Gets shared
     * @return string
     */
    public function getShared()
    {
        return $this->shared;
    }
  
    /**
     * Sets shared
     * @param string $shared Specifies which users should be included in the response. Multiple values can be used in the query by using a comma separated list of shared values. If the requestor does not have account administrator privileges, the shared_to value is used. Requestors that do not have account administrator privileges can only use the shared_to, any other setting will result in an error. The accepted values are:  -not_shared: Returns account users that the specified item type is not being shared with and that are not sharing the specified item type with the user.  User X (Share) X Account user  -shared_to: Returns account users that the specified item type is not being shared with and who are sharing the specified item type with the user (only shared to the user).  User X (Share) Account user  -shared_from: Returns account users that the specified item type is being shared with and who are not sharing the specified item type with the user (only shared from the user).  User (Share) >> Account user  -shared_to_and_from: Returns account users that the specified item type is being shared with and who are sharing the specified item type with the user.  User << (Share) >> Account user
     * @return $this
     */
    public function setShared($shared)
    {
        $this->shared = $shared;
        return $this;
    }
    /**
      * $start_position If the response set exceeds Count, this can be used to specify that the method should return users starting at the specified index. The first index is 0, and should be used in the first GET call. Typically this number is a multiple of Count. If no value is specified, this defaults to be 0.
      * @var string
      */
    protected $start_position;

    /**
     * Gets start_position
     * @return string
     */
    public function getStartPosition()
    {
        return $this->start_position;
    }
  
    /**
     * Sets start_position
     * @param string $start_position If the response set exceeds Count, this can be used to specify that the method should return users starting at the specified index. The first index is 0, and should be used in the first GET call. Typically this number is a multiple of Count. If no value is specified, this defaults to be 0.
     * @return $this
     */
    public function setStartPosition($start_position)
    {
        $this->start_position = $start_position;
        return $this;
    }
    /**
      * $user_ids A comma separated list of userIds for whom the shared item information is being requested.
      * @var string
      */
    protected $user_ids;

    /**
     * Gets user_ids
     * @return string
     */
    public function getUserIds()
    {
        return $this->user_ids;
    }
  
    /**
     * Sets user_ids
     * @param string $user_ids A comma separated list of userIds for whom the shared item information is being requested.
     * @return $this
     */
    public function setUserIds($user_ids)
    {
        $this->user_ids = $user_ids;
        return $this;
    }
}
class UpdateAccountSignatureByIdOptions
{
    /**
      * $close_existing_signature 
      * @var string
      */
    protected $close_existing_signature;

    /**
     * Gets close_existing_signature
     * @return string
     */
    public function getCloseExistingSignature()
    {
        return $this->close_existing_signature;
    }
  
    /**
     * Sets close_existing_signature
     * @param string $close_existing_signature 
     * @return $this
     */
    public function setCloseExistingSignature($close_existing_signature)
    {
        $this->close_existing_signature = $close_existing_signature;
        return $this;
    }
}
class UpdateAccountSignatureImageOptions
{
    /**
      * $transparent_png 
      * @var string
      */
    protected $transparent_png;

    /**
     * Gets transparent_png
     * @return string
     */
    public function getTransparentPng()
    {
        return $this->transparent_png;
    }
  
    /**
     * Sets transparent_png
     * @param string $transparent_png 
     * @return $this
     */
    public function setTransparentPng($transparent_png)
    {
        $this->transparent_png = $transparent_png;
        return $this;
    }
}
class UpdateConsumerDisclosureOptions
{
    /**
      * $include_metadata 
      * @var string
      */
    protected $include_metadata;

    /**
     * Gets include_metadata
     * @return string
     */
    public function getIncludeMetadata()
    {
        return $this->include_metadata;
    }
  
    /**
     * Sets include_metadata
     * @param string $include_metadata 
     * @return $this
     */
    public function setIncludeMetadata($include_metadata)
    {
        $this->include_metadata = $include_metadata;
        return $this;
    }
}
class UpdateCustomFieldOptions
{
    /**
      * $apply_to_templates 
      * @var string
      */
    protected $apply_to_templates;

    /**
     * Gets apply_to_templates
     * @return string
     */
    public function getApplyToTemplates()
    {
        return $this->apply_to_templates;
    }
  
    /**
     * Sets apply_to_templates
     * @param string $apply_to_templates 
     * @return $this
     */
    public function setApplyToTemplates($apply_to_templates)
    {
        $this->apply_to_templates = $apply_to_templates;
        return $this;
    }
}
class UpdatePermissionProfileOptions
{
    /**
      * $include 
      * @var string
      */
    protected $include;

    /**
     * Gets include
     * @return string
     */
    public function getInclude()
    {
        return $this->include;
    }
  
    /**
     * Sets include
     * @param string $include 
     * @return $this
     */
    public function setInclude($include)
    {
        $this->include = $include;
        return $this;
    }
}
class UpdateSharedAccessOptions
{
    /**
      * $item_type 
      * @var string
      */
    protected $item_type;

    /**
     * Gets item_type
     * @return string
     */
    public function getItemType()
    {
        return $this->item_type;
    }
  
    /**
     * Sets item_type
     * @param string $item_type 
     * @return $this
     */
    public function setItemType($item_type)
    {
        $this->item_type = $item_type;
        return $this;
    }
    /**
      * $preserve_existing_shared_access 
      * @var string
      */
    protected $preserve_existing_shared_access;

    /**
     * Gets preserve_existing_shared_access
     * @return string
     */
    public function getPreserveExistingSharedAccess()
    {
        return $this->preserve_existing_shared_access;
    }
  
    /**
     * Sets preserve_existing_shared_access
     * @param string $preserve_existing_shared_access 
     * @return $this
     */
    public function setPreserveExistingSharedAccess($preserve_existing_shared_access)
    {
        $this->preserve_existing_shared_access = $preserve_existing_shared_access;
        return $this;
    }
    /**
      * $user_ids 
      * @var string
      */
    protected $user_ids;

    /**
     * Gets user_ids
     * @return string
     */
    public function getUserIds()
    {
        return $this->user_ids;
    }
  
    /**
     * Sets user_ids
     * @param string $user_ids 
     * @return $this
     */
    public function setUserIds($user_ids)
    {
        $this->user_ids = $user_ids;
        return $this;
    }
}


namespace DocuSign\eSign\Api;

use \DocuSign\eSign\Client\ApiClient;
use \DocuSign\eSign\Client\ApiException;
use \DocuSign\eSign\Configuration;
use \DocuSign\eSign\ObjectSerializer;

/**
 * AccountsApi Class Doc Comment
 *
 * @category Class
 * @package  DocuSign\eSign
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AccountsApi
{
    /**
     * API Client
     *
     * @var \DocuSign\eSign\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \DocuSign\eSign\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\DocuSign\eSign\Client\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \DocuSign\eSign\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \DocuSign\eSign\Client\ApiClient $apiClient set the API client
     *
     * @return AccountsApi
     */
    public function setApiClient(\DocuSign\eSign\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation create
     *
     * Creates new accounts.
     *
     * @param \DocuSign\eSign\Model\NewAccountDefinition $new_account_definition  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\NewAccountSummary
     */
    public function create($new_account_definition = null, AccountsApi\CreateOptions $options = null)
    {
        list($response) = $this->createWithHttpInfo($new_account_definition, $options);
        return $response;
    }

    /**
     * Operation createWithHttpInfo
     *
     * Creates new accounts.
     *
     * @param \DocuSign\eSign\Model\NewAccountDefinition $new_account_definition  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\NewAccountSummary, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWithHttpInfo($new_account_definition = null, AccountsApi\CreateOptions $options = null)
    {
        // parse inputs
        $resourcePath = "/v2.1/accounts";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getPreviewBillingPlan() !== null) {
            $queryParams['preview_billing_plan'] = $this->apiClient->getSerializer()->toQueryValue($options->getPreviewBillingPlan());
        }
        }

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($new_account_definition)) {
            $_tempBody = $new_account_definition;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\NewAccountSummary',
                '/v2.1/accounts'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\NewAccountSummary', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\NewAccountSummary', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createAccountSignatures
     *
     * Adds/updates one or more account signatures. This request may include images in multi-part format.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\AccountSignaturesInformation $account_signatures_information  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSignaturesInformation
     */
    public function createAccountSignatures($account_id, $account_signatures_information = null, AccountsApi\CreateAccountSignaturesOptions $options = null)
    {
        list($response) = $this->createAccountSignaturesWithHttpInfo($account_id, $account_signatures_information, $options);
        return $response;
    }

    /**
     * Operation createAccountSignaturesWithHttpInfo
     *
     * Adds/updates one or more account signatures. This request may include images in multi-part format.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\AccountSignaturesInformation $account_signatures_information  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSignaturesInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountSignaturesWithHttpInfo($account_id, $account_signatures_information = null, AccountsApi\CreateAccountSignaturesOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling createAccountSignatures');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/signatures";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getDecodeOnly() !== null) {
            $queryParams['decode_only'] = $this->apiClient->getSerializer()->toQueryValue($options->getDecodeOnly());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($account_signatures_information)) {
            $_tempBody = $account_signatures_information;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSignaturesInformation',
                '/v2.1/accounts/{accountId}/signatures'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSignaturesInformation', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSignaturesInformation', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createBrand
     *
     * Creates one or more brand profile files for the account.
     *
    * @param string $account_id The external account number (int) or account ID GUID.
     * @param \DocuSign\eSign\Model\Brand $brand  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\BrandsResponse
     */
    public function createBrand($account_id, $brand = null)
    {
        list($response) = $this->createBrandWithHttpInfo($account_id, $brand);
        return $response;
    }

    /**
     * Operation createBrandWithHttpInfo
     *
     * Creates one or more brand profile files for the account.
     *
    * @param string $account_id The external account number (int) or account ID GUID.
     * @param \DocuSign\eSign\Model\Brand $brand  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\BrandsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBrandWithHttpInfo($account_id, $brand = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling createBrand');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($brand)) {
            $_tempBody = $brand;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\BrandsResponse',
                '/v2.1/accounts/{accountId}/brands'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\BrandsResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\BrandsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createCustomField
     *
     * Creates an acount custom field.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\CustomField $custom_field  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\CustomFields
     */
    public function createCustomField($account_id, $custom_field = null, AccountsApi\CreateCustomFieldOptions $options = null)
    {
        list($response) = $this->createCustomFieldWithHttpInfo($account_id, $custom_field, $options);
        return $response;
    }

    /**
     * Operation createCustomFieldWithHttpInfo
     *
     * Creates an acount custom field.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\CustomField $custom_field  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\CustomFields, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCustomFieldWithHttpInfo($account_id, $custom_field = null, AccountsApi\CreateCustomFieldOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling createCustomField');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/custom_fields";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getApplyToTemplates() !== null) {
            $queryParams['apply_to_templates'] = $this->apiClient->getSerializer()->toQueryValue($options->getApplyToTemplates());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($custom_field)) {
            $_tempBody = $custom_field;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\CustomFields',
                '/v2.1/accounts/{accountId}/custom_fields'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\CustomFields', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\CustomFields', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createPermissionProfile
     *
     * Creates a new permission profile in the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\PermissionProfile $permission_profile  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\PermissionProfile
     */
    public function createPermissionProfile($account_id, $permission_profile = null, AccountsApi\CreatePermissionProfileOptions $options = null)
    {
        list($response) = $this->createPermissionProfileWithHttpInfo($account_id, $permission_profile, $options);
        return $response;
    }

    /**
     * Operation createPermissionProfileWithHttpInfo
     *
     * Creates a new permission profile in the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\PermissionProfile $permission_profile  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\PermissionProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPermissionProfileWithHttpInfo($account_id, $permission_profile = null, AccountsApi\CreatePermissionProfileOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling createPermissionProfile');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/permission_profiles";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getInclude() !== null) {
            $queryParams['include'] = $this->apiClient->getSerializer()->toQueryValue($options->getInclude());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($permission_profile)) {
            $_tempBody = $permission_profile;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\PermissionProfile',
                '/v2.1/accounts/{accountId}/permission_profiles'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\PermissionProfile', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\PermissionProfile', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createReportInProductCreate
     *
     * Creates a customized report
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\ReportInProductRunRequest $report_in_product_run_request  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ReportInProductSaveResponse
     */
    public function createReportInProductCreate($account_id, $report_in_product_run_request = null)
    {
        list($response) = $this->createReportInProductCreateWithHttpInfo($account_id, $report_in_product_run_request);
        return $response;
    }

    /**
     * Operation createReportInProductCreateWithHttpInfo
     *
     * Creates a customized report
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\ReportInProductRunRequest $report_in_product_run_request  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ReportInProductSaveResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createReportInProductCreateWithHttpInfo($account_id, $report_in_product_run_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling createReportInProductCreate');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/reports";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($report_in_product_run_request)) {
            $_tempBody = $report_in_product_run_request;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ReportInProductSaveResponse',
                '/v2.1/accounts/{accountId}/reports'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ReportInProductSaveResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ReportInProductSaveResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation delete
     *
     * Deletes the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function delete($account_id)
    {
        list($response) = $this->deleteWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation deleteWithHttpInfo
     *
     * Deletes the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling delete');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteAccountSignature
     *
     * Close the specified signature by Id.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $signature_id The ID of the signature being accessed.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function deleteAccountSignature($account_id, $signature_id)
    {
        list($response) = $this->deleteAccountSignatureWithHttpInfo($account_id, $signature_id);
        return $response;
    }

    /**
     * Operation deleteAccountSignatureWithHttpInfo
     *
     * Close the specified signature by Id.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $signature_id The ID of the signature being accessed.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAccountSignatureWithHttpInfo($account_id, $signature_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling deleteAccountSignature');
        }
        // verify the required parameter 'signature_id' is set
        if ($signature_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $signature_id when calling deleteAccountSignature');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/signatures/{signatureId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($signature_id !== null) {
            $resourcePath = str_replace(
                "{" . "signatureId" . "}",
                $this->apiClient->getSerializer()->toPathValue($signature_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/signatures/{signatureId}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteAccountSignatureImage
     *
     * Deletes a signature, initials, or stamps image.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $image_type One of **signature_image** or **initials_image**.
    * @param string $signature_id The ID of the signature being accessed.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSignature
     */
    public function deleteAccountSignatureImage($account_id, $image_type, $signature_id)
    {
        list($response) = $this->deleteAccountSignatureImageWithHttpInfo($account_id, $image_type, $signature_id);
        return $response;
    }

    /**
     * Operation deleteAccountSignatureImageWithHttpInfo
     *
     * Deletes a signature, initials, or stamps image.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $image_type One of **signature_image** or **initials_image**.
    * @param string $signature_id The ID of the signature being accessed.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSignature, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAccountSignatureImageWithHttpInfo($account_id, $image_type, $signature_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling deleteAccountSignatureImage');
        }
        // verify the required parameter 'image_type' is set
        if ($image_type === null) {
            throw new \InvalidArgumentException('Missing the required parameter $image_type when calling deleteAccountSignatureImage');
        }
        // verify the required parameter 'signature_id' is set
        if ($signature_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $signature_id when calling deleteAccountSignatureImage');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/signatures/{signatureId}/{imageType}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                "{" . "imageType" . "}",
                $this->apiClient->getSerializer()->toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($signature_id !== null) {
            $resourcePath = str_replace(
                "{" . "signatureId" . "}",
                $this->apiClient->getSerializer()->toPathValue($signature_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSignature',
                '/v2.1/accounts/{accountId}/signatures/{signatureId}/{imageType}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSignature', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSignature', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteBrand
     *
     * Removes a brand.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function deleteBrand($account_id, $brand_id)
    {
        list($response) = $this->deleteBrandWithHttpInfo($account_id, $brand_id);
        return $response;
    }

    /**
     * Operation deleteBrandWithHttpInfo
     *
     * Removes a brand.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBrandWithHttpInfo($account_id, $brand_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling deleteBrand');
        }
        // verify the required parameter 'brand_id' is set
        if ($brand_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $brand_id when calling deleteBrand');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands/{brandId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                "{" . "brandId" . "}",
                $this->apiClient->getSerializer()->toPathValue($brand_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/brands/{brandId}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteBrandLogoByType
     *
     * Delete one branding logo.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
    * @param string $logo_type One of **Primary**, **Secondary** or **Email**.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function deleteBrandLogoByType($account_id, $brand_id, $logo_type)
    {
        list($response) = $this->deleteBrandLogoByTypeWithHttpInfo($account_id, $brand_id, $logo_type);
        return $response;
    }

    /**
     * Operation deleteBrandLogoByTypeWithHttpInfo
     *
     * Delete one branding logo.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
    * @param string $logo_type One of **Primary**, **Secondary** or **Email**.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBrandLogoByTypeWithHttpInfo($account_id, $brand_id, $logo_type)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling deleteBrandLogoByType');
        }
        // verify the required parameter 'brand_id' is set
        if ($brand_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $brand_id when calling deleteBrandLogoByType');
        }
        // verify the required parameter 'logo_type' is set
        if ($logo_type === null) {
            throw new \InvalidArgumentException('Missing the required parameter $logo_type when calling deleteBrandLogoByType');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands/{brandId}/logos/{logoType}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                "{" . "brandId" . "}",
                $this->apiClient->getSerializer()->toPathValue($brand_id),
                $resourcePath
            );
        }
        // path params
        if ($logo_type !== null) {
            $resourcePath = str_replace(
                "{" . "logoType" . "}",
                $this->apiClient->getSerializer()->toPathValue($logo_type),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/brands/{brandId}/logos/{logoType}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteBrands
     *
     * Deletes one or more brand profiles.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\BrandsRequest $brands_request  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\BrandsResponse
     */
    public function deleteBrands($account_id, $brands_request = null)
    {
        list($response) = $this->deleteBrandsWithHttpInfo($account_id, $brands_request);
        return $response;
    }

    /**
     * Operation deleteBrandsWithHttpInfo
     *
     * Deletes one or more brand profiles.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\BrandsRequest $brands_request  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\BrandsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBrandsWithHttpInfo($account_id, $brands_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling deleteBrands');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($brands_request)) {
            $_tempBody = $brands_request;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\BrandsResponse',
                '/v2.1/accounts/{accountId}/brands'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\BrandsResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\BrandsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteCaptiveRecipient
     *
     * Deletes the signature for one or more captive recipient records.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $recipient_part 
     * @param \DocuSign\eSign\Model\CaptiveRecipientInformation $captive_recipient_information  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\CaptiveRecipientInformation
     */
    public function deleteCaptiveRecipient($account_id, $recipient_part, $captive_recipient_information = null)
    {
        list($response) = $this->deleteCaptiveRecipientWithHttpInfo($account_id, $recipient_part, $captive_recipient_information);
        return $response;
    }

    /**
     * Operation deleteCaptiveRecipientWithHttpInfo
     *
     * Deletes the signature for one or more captive recipient records.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $recipient_part 
     * @param \DocuSign\eSign\Model\CaptiveRecipientInformation $captive_recipient_information  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\CaptiveRecipientInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCaptiveRecipientWithHttpInfo($account_id, $recipient_part, $captive_recipient_information = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling deleteCaptiveRecipient');
        }
        // verify the required parameter 'recipient_part' is set
        if ($recipient_part === null) {
            throw new \InvalidArgumentException('Missing the required parameter $recipient_part when calling deleteCaptiveRecipient');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/captive_recipients/{recipientPart}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($recipient_part !== null) {
            $resourcePath = str_replace(
                "{" . "recipientPart" . "}",
                $this->apiClient->getSerializer()->toPathValue($recipient_part),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($captive_recipient_information)) {
            $_tempBody = $captive_recipient_information;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\CaptiveRecipientInformation',
                '/v2.1/accounts/{accountId}/captive_recipients/{recipientPart}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\CaptiveRecipientInformation', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\CaptiveRecipientInformation', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteCustomField
     *
     * Delete an existing account custom field.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $custom_field_id 
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function deleteCustomField($account_id, $custom_field_id, AccountsApi\DeleteCustomFieldOptions $options = null)
    {
        list($response) = $this->deleteCustomFieldWithHttpInfo($account_id, $custom_field_id, $options);
        return $response;
    }

    /**
     * Operation deleteCustomFieldWithHttpInfo
     *
     * Delete an existing account custom field.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $custom_field_id 
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCustomFieldWithHttpInfo($account_id, $custom_field_id, AccountsApi\DeleteCustomFieldOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling deleteCustomField');
        }
        // verify the required parameter 'custom_field_id' is set
        if ($custom_field_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $custom_field_id when calling deleteCustomField');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/custom_fields/{customFieldId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getApplyToTemplates() !== null) {
            $queryParams['apply_to_templates'] = $this->apiClient->getSerializer()->toQueryValue($options->getApplyToTemplates());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($custom_field_id !== null) {
            $resourcePath = str_replace(
                "{" . "customFieldId" . "}",
                $this->apiClient->getSerializer()->toPathValue($custom_field_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/custom_fields/{customFieldId}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteENoteConfiguration
     *
     * Deletes configuration information for the eNote eOriginal integration.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function deleteENoteConfiguration($account_id)
    {
        list($response) = $this->deleteENoteConfigurationWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation deleteENoteConfigurationWithHttpInfo
     *
     * Deletes configuration information for the eNote eOriginal integration.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteENoteConfigurationWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling deleteENoteConfiguration');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/enote_configuration";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/settings/enote_configuration'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deletePermissionProfile
     *
     * Deletes a permissions profile within the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $permission_profile_id 
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function deletePermissionProfile($account_id, $permission_profile_id, AccountsApi\DeletePermissionProfileOptions $options = null)
    {
        list($response) = $this->deletePermissionProfileWithHttpInfo($account_id, $permission_profile_id, $options);
        return $response;
    }

    /**
     * Operation deletePermissionProfileWithHttpInfo
     *
     * Deletes a permissions profile within the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $permission_profile_id 
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePermissionProfileWithHttpInfo($account_id, $permission_profile_id, AccountsApi\DeletePermissionProfileOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling deletePermissionProfile');
        }
        // verify the required parameter 'permission_profile_id' is set
        if ($permission_profile_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $permission_profile_id when calling deletePermissionProfile');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/permission_profiles/{permissionProfileId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getMoveUsersTo() !== null) {
            $queryParams['move_users_to'] = $this->apiClient->getSerializer()->toQueryValue($options->getMoveUsersTo());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($permission_profile_id !== null) {
            $resourcePath = str_replace(
                "{" . "permissionProfileId" . "}",
                $this->apiClient->getSerializer()->toPathValue($permission_profile_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/permission_profiles/{permissionProfileId}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteReportInProduct
     *
     * Removes a customized report
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $id 
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ReportInProductSaveResponse
     */
    public function deleteReportInProduct($account_id, $id)
    {
        list($response) = $this->deleteReportInProductWithHttpInfo($account_id, $id);
        return $response;
    }

    /**
     * Operation deleteReportInProductWithHttpInfo
     *
     * Removes a customized report
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $id 
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ReportInProductSaveResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteReportInProductWithHttpInfo($account_id, $id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling deleteReportInProduct');
        }
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling deleteReportInProduct');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/reports/{id}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                $this->apiClient->getSerializer()->toPathValue($id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ReportInProductSaveResponse',
                '/v2.1/accounts/{accountId}/reports/{id}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ReportInProductSaveResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ReportInProductSaveResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getAccountIdentityVerification
     *
     * Get the list of identity verification options for an account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountIdentityVerificationResponse
     */
    public function getAccountIdentityVerification($account_id)
    {
        list($response) = $this->getAccountIdentityVerificationWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getAccountIdentityVerificationWithHttpInfo
     *
     * Get the list of identity verification options for an account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountIdentityVerificationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountIdentityVerificationWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getAccountIdentityVerification');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/identity_verification";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountIdentityVerificationResponse',
                '/v2.1/accounts/{accountId}/identity_verification'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountIdentityVerificationResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountIdentityVerificationResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getAccountInformation
     *
     * Retrieves the account information for the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountInformation
     */
    public function getAccountInformation($account_id, AccountsApi\GetAccountInformationOptions $options = null)
    {
        list($response) = $this->getAccountInformationWithHttpInfo($account_id, $options);
        return $response;
    }

    /**
     * Operation getAccountInformationWithHttpInfo
     *
     * Retrieves the account information for the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountInformationWithHttpInfo($account_id, AccountsApi\GetAccountInformationOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getAccountInformation');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getIncludeAccountSettings() !== null) {
            $queryParams['include_account_settings'] = $this->apiClient->getSerializer()->toQueryValue($options->getIncludeAccountSettings());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountInformation',
                '/v2.1/accounts/{accountId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountInformation', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountInformation', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getAccountSignature
     *
     * Returns information about a single signature by specifed signatureId.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $signature_id The ID of the signature being accessed.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSignature
     */
    public function getAccountSignature($account_id, $signature_id)
    {
        list($response) = $this->getAccountSignatureWithHttpInfo($account_id, $signature_id);
        return $response;
    }

    /**
     * Operation getAccountSignatureWithHttpInfo
     *
     * Returns information about a single signature by specifed signatureId.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $signature_id The ID of the signature being accessed.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSignature, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountSignatureWithHttpInfo($account_id, $signature_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getAccountSignature');
        }
        // verify the required parameter 'signature_id' is set
        if ($signature_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $signature_id when calling getAccountSignature');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/signatures/{signatureId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($signature_id !== null) {
            $resourcePath = str_replace(
                "{" . "signatureId" . "}",
                $this->apiClient->getSerializer()->toPathValue($signature_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSignature',
                '/v2.1/accounts/{accountId}/signatures/{signatureId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSignature', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSignature', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getAccountSignatureImage
     *
     * Returns a signature, initials, or stamps image.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $image_type One of **signature_image** or **initials_image**.
    * @param string $signature_id The ID of the signature being accessed.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \SplFileObject
     */
    public function getAccountSignatureImage($account_id, $image_type, $signature_id, AccountsApi\GetAccountSignatureImageOptions $options = null)
    {
        list($response) = $this->getAccountSignatureImageWithHttpInfo($account_id, $image_type, $signature_id, $options);
        return $response;
    }

    /**
     * Operation getAccountSignatureImageWithHttpInfo
     *
     * Returns a signature, initials, or stamps image.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $image_type One of **signature_image** or **initials_image**.
    * @param string $signature_id The ID of the signature being accessed.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountSignatureImageWithHttpInfo($account_id, $image_type, $signature_id, AccountsApi\GetAccountSignatureImageOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getAccountSignatureImage');
        }
        // verify the required parameter 'image_type' is set
        if ($image_type === null) {
            throw new \InvalidArgumentException('Missing the required parameter $image_type when calling getAccountSignatureImage');
        }
        // verify the required parameter 'signature_id' is set
        if ($signature_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $signature_id when calling getAccountSignatureImage');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/signatures/{signatureId}/{imageType}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['image/gif']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getIncludeChrome() !== null) {
            $queryParams['include_chrome'] = $this->apiClient->getSerializer()->toQueryValue($options->getIncludeChrome());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                "{" . "imageType" . "}",
                $this->apiClient->getSerializer()->toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($signature_id !== null) {
            $resourcePath = str_replace(
                "{" . "signatureId" . "}",
                $this->apiClient->getSerializer()->toPathValue($signature_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SplFileObject',
                '/v2.1/accounts/{accountId}/signatures/{signatureId}/{imageType}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SplFileObject', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getAccountSignatures
     *
     * Returns the managed signature definitions for the account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSignaturesInformation
     */
    public function getAccountSignatures($account_id, AccountsApi\GetAccountSignaturesOptions $options = null)
    {
        list($response) = $this->getAccountSignaturesWithHttpInfo($account_id, $options);
        return $response;
    }

    /**
     * Operation getAccountSignaturesWithHttpInfo
     *
     * Returns the managed signature definitions for the account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSignaturesInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountSignaturesWithHttpInfo($account_id, AccountsApi\GetAccountSignaturesOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getAccountSignatures');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/signatures";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getStampFormat() !== null) {
            $queryParams['stamp_format'] = $this->apiClient->getSerializer()->toQueryValue($options->getStampFormat());
        }
        // query params
        if ($options->getStampName() !== null) {
            $queryParams['stamp_name'] = $this->apiClient->getSerializer()->toQueryValue($options->getStampName());
        }
        // query params
        if ($options->getStampType() !== null) {
            $queryParams['stamp_type'] = $this->apiClient->getSerializer()->toQueryValue($options->getStampType());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSignaturesInformation',
                '/v2.1/accounts/{accountId}/signatures'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSignaturesInformation', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSignaturesInformation', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getAccountTabSettings
     *
     * Returns tab settings list for specified account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\TabAccountSettings
     */
    public function getAccountTabSettings($account_id)
    {
        list($response) = $this->getAccountTabSettingsWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getAccountTabSettingsWithHttpInfo
     *
     * Returns tab settings list for specified account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\TabAccountSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountTabSettingsWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getAccountTabSettings');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/tabs";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\TabAccountSettings',
                '/v2.1/accounts/{accountId}/settings/tabs'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\TabAccountSettings', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\TabAccountSettings', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getAllPaymentGatewayAccounts
     *
     * Get all payment gateway account for the provided accountId
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\PaymentGatewayAccountsInfo
     */
    public function getAllPaymentGatewayAccounts($account_id)
    {
        list($response) = $this->getAllPaymentGatewayAccountsWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getAllPaymentGatewayAccountsWithHttpInfo
     *
     * Get all payment gateway account for the provided accountId
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\PaymentGatewayAccountsInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllPaymentGatewayAccountsWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getAllPaymentGatewayAccounts');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/payment_gateway_accounts";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\PaymentGatewayAccountsInfo',
                '/v2.1/accounts/{accountId}/payment_gateway_accounts'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\PaymentGatewayAccountsInfo', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\PaymentGatewayAccountsInfo', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getBillingCharges
     *
     * Gets list of recurring and usage charges for the account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\BillingChargeResponse
     */
    public function getBillingCharges($account_id, AccountsApi\GetBillingChargesOptions $options = null)
    {
        list($response) = $this->getBillingChargesWithHttpInfo($account_id, $options);
        return $response;
    }

    /**
     * Operation getBillingChargesWithHttpInfo
     *
     * Gets list of recurring and usage charges for the account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\BillingChargeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBillingChargesWithHttpInfo($account_id, AccountsApi\GetBillingChargesOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getBillingCharges');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/billing_charges";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getIncludeCharges() !== null) {
            $queryParams['include_charges'] = $this->apiClient->getSerializer()->toQueryValue($options->getIncludeCharges());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\BillingChargeResponse',
                '/v2.1/accounts/{accountId}/billing_charges'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\BillingChargeResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\BillingChargeResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getBrand
     *
     * Get information for a specific brand.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\Brand
     */
    public function getBrand($account_id, $brand_id, AccountsApi\GetBrandOptions $options = null)
    {
        list($response) = $this->getBrandWithHttpInfo($account_id, $brand_id, $options);
        return $response;
    }

    /**
     * Operation getBrandWithHttpInfo
     *
     * Get information for a specific brand.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\Brand, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandWithHttpInfo($account_id, $brand_id, AccountsApi\GetBrandOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getBrand');
        }
        // verify the required parameter 'brand_id' is set
        if ($brand_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $brand_id when calling getBrand');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands/{brandId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getIncludeExternalReferences() !== null) {
            $queryParams['include_external_references'] = $this->apiClient->getSerializer()->toQueryValue($options->getIncludeExternalReferences());
        }
        // query params
        if ($options->getIncludeLogos() !== null) {
            $queryParams['include_logos'] = $this->apiClient->getSerializer()->toQueryValue($options->getIncludeLogos());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                "{" . "brandId" . "}",
                $this->apiClient->getSerializer()->toPathValue($brand_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\Brand',
                '/v2.1/accounts/{accountId}/brands/{brandId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\Brand', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\Brand', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getBrandExportFile
     *
     * Export a specific brand.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function getBrandExportFile($account_id, $brand_id)
    {
        list($response) = $this->getBrandExportFileWithHttpInfo($account_id, $brand_id);
        return $response;
    }

    /**
     * Operation getBrandExportFileWithHttpInfo
     *
     * Export a specific brand.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandExportFileWithHttpInfo($account_id, $brand_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getBrandExportFile');
        }
        // verify the required parameter 'brand_id' is set
        if ($brand_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $brand_id when calling getBrandExportFile');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands/{brandId}/file";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                "{" . "brandId" . "}",
                $this->apiClient->getSerializer()->toPathValue($brand_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/brands/{brandId}/file'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getBrandLogoByType
     *
     * Obtains the specified image for a brand.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
    * @param string $logo_type One of **Primary**, **Secondary** or **Email**.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \SplFileObject
     */
    public function getBrandLogoByType($account_id, $brand_id, $logo_type)
    {
        list($response) = $this->getBrandLogoByTypeWithHttpInfo($account_id, $brand_id, $logo_type);
        return $response;
    }

    /**
     * Operation getBrandLogoByTypeWithHttpInfo
     *
     * Obtains the specified image for a brand.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
    * @param string $logo_type One of **Primary**, **Secondary** or **Email**.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandLogoByTypeWithHttpInfo($account_id, $brand_id, $logo_type)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getBrandLogoByType');
        }
        // verify the required parameter 'brand_id' is set
        if ($brand_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $brand_id when calling getBrandLogoByType');
        }
        // verify the required parameter 'logo_type' is set
        if ($logo_type === null) {
            throw new \InvalidArgumentException('Missing the required parameter $logo_type when calling getBrandLogoByType');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands/{brandId}/logos/{logoType}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['image/png']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                "{" . "brandId" . "}",
                $this->apiClient->getSerializer()->toPathValue($brand_id),
                $resourcePath
            );
        }
        // path params
        if ($logo_type !== null) {
            $resourcePath = str_replace(
                "{" . "logoType" . "}",
                $this->apiClient->getSerializer()->toPathValue($logo_type),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SplFileObject',
                '/v2.1/accounts/{accountId}/brands/{brandId}/logos/{logoType}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SplFileObject', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getBrandResources
     *
     * Returns the specified account's list of branding resources (metadata).
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\BrandResourcesList
     */
    public function getBrandResources($account_id, $brand_id)
    {
        list($response) = $this->getBrandResourcesWithHttpInfo($account_id, $brand_id);
        return $response;
    }

    /**
     * Operation getBrandResourcesWithHttpInfo
     *
     * Returns the specified account's list of branding resources (metadata).
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\BrandResourcesList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandResourcesWithHttpInfo($account_id, $brand_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getBrandResources');
        }
        // verify the required parameter 'brand_id' is set
        if ($brand_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $brand_id when calling getBrandResources');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands/{brandId}/resources";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                "{" . "brandId" . "}",
                $this->apiClient->getSerializer()->toPathValue($brand_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\BrandResourcesList',
                '/v2.1/accounts/{accountId}/brands/{brandId}/resources'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\BrandResourcesList', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\BrandResourcesList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getBrandResourcesByContentType
     *
     * Returns the specified branding resource file.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
    * @param string $resource_content_type 
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function getBrandResourcesByContentType($account_id, $brand_id, $resource_content_type, AccountsApi\GetBrandResourcesByContentTypeOptions $options = null)
    {
        list($response) = $this->getBrandResourcesByContentTypeWithHttpInfo($account_id, $brand_id, $resource_content_type, $options);
        return $response;
    }

    /**
     * Operation getBrandResourcesByContentTypeWithHttpInfo
     *
     * Returns the specified branding resource file.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
    * @param string $resource_content_type 
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandResourcesByContentTypeWithHttpInfo($account_id, $brand_id, $resource_content_type, AccountsApi\GetBrandResourcesByContentTypeOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getBrandResourcesByContentType');
        }
        // verify the required parameter 'brand_id' is set
        if ($brand_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $brand_id when calling getBrandResourcesByContentType');
        }
        // verify the required parameter 'resource_content_type' is set
        if ($resource_content_type === null) {
            throw new \InvalidArgumentException('Missing the required parameter $resource_content_type when calling getBrandResourcesByContentType');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands/{brandId}/resources/{resourceContentType}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getLangcode() !== null) {
            $queryParams['langcode'] = $this->apiClient->getSerializer()->toQueryValue($options->getLangcode());
        }
        // query params
        if ($options->getReturnMaster() !== null) {
            $queryParams['return_master'] = $this->apiClient->getSerializer()->toQueryValue($options->getReturnMaster());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                "{" . "brandId" . "}",
                $this->apiClient->getSerializer()->toPathValue($brand_id),
                $resourcePath
            );
        }
        // path params
        if ($resource_content_type !== null) {
            $resourcePath = str_replace(
                "{" . "resourceContentType" . "}",
                $this->apiClient->getSerializer()->toPathValue($resource_content_type),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/brands/{brandId}/resources/{resourceContentType}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getConsumerDisclosure
     *
     * Gets the Electronic Record and Signature Disclosure.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $lang_code The simple type enumeration the language used in the response. The supported languages, with the language value shown in parenthesis, are:Arabic (ar), Armenian (hy), Bulgarian (bg), Czech (cs), Chinese Simplified (zh_CN), Chinese Traditional (zh_TW), Croatian (hr), Danish (da), Dutch (nl), English US (en), English UK (en_GB), Estonian (et), Farsi (fa), Finnish (fi), French (fr), French Canada (fr_CA), German (de), Greek (el), Hebrew (he), Hindi (hi), Hungarian (hu), Bahasa Indonesia (id), Italian (it), Japanese (ja), Korean (ko), Latvian (lv), Lithuanian (lt), Bahasa Melayu (ms), Norwegian (no), Polish (pl), Portuguese (pt), Portuguese Brazil (pt_BR), Romanian (ro), Russian (ru), Serbian (sr), Slovak (sk), Slovenian (sl), Spanish (es),Spanish Latin America (es_MX), Swedish (sv), Thai (th), Turkish (tr), Ukrainian (uk) and Vietnamese (vi). Additionally, the value can be set to Ã¯Â¿Â½browserÃ¯Â¿Â½ to automatically detect the browser language being used by the viewer and display the disclosure in that language.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ConsumerDisclosure
     */
    public function getConsumerDisclosure($account_id, $lang_code)
    {
        list($response) = $this->getConsumerDisclosureWithHttpInfo($account_id, $lang_code);
        return $response;
    }

    /**
     * Operation getConsumerDisclosureWithHttpInfo
     *
     * Gets the Electronic Record and Signature Disclosure.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $lang_code The simple type enumeration the language used in the response. The supported languages, with the language value shown in parenthesis, are:Arabic (ar), Armenian (hy), Bulgarian (bg), Czech (cs), Chinese Simplified (zh_CN), Chinese Traditional (zh_TW), Croatian (hr), Danish (da), Dutch (nl), English US (en), English UK (en_GB), Estonian (et), Farsi (fa), Finnish (fi), French (fr), French Canada (fr_CA), German (de), Greek (el), Hebrew (he), Hindi (hi), Hungarian (hu), Bahasa Indonesia (id), Italian (it), Japanese (ja), Korean (ko), Latvian (lv), Lithuanian (lt), Bahasa Melayu (ms), Norwegian (no), Polish (pl), Portuguese (pt), Portuguese Brazil (pt_BR), Romanian (ro), Russian (ru), Serbian (sr), Slovak (sk), Slovenian (sl), Spanish (es),Spanish Latin America (es_MX), Swedish (sv), Thai (th), Turkish (tr), Ukrainian (uk) and Vietnamese (vi). Additionally, the value can be set to Ã¯Â¿Â½browserÃ¯Â¿Â½ to automatically detect the browser language being used by the viewer and display the disclosure in that language.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ConsumerDisclosure, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsumerDisclosureWithHttpInfo($account_id, $lang_code)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getConsumerDisclosure');
        }
        // verify the required parameter 'lang_code' is set
        if ($lang_code === null) {
            throw new \InvalidArgumentException('Missing the required parameter $lang_code when calling getConsumerDisclosure');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/consumer_disclosure/{langCode}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($lang_code !== null) {
            $resourcePath = str_replace(
                "{" . "langCode" . "}",
                $this->apiClient->getSerializer()->toPathValue($lang_code),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ConsumerDisclosure',
                '/v2.1/accounts/{accountId}/consumer_disclosure/{langCode}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ConsumerDisclosure', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ConsumerDisclosure', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getConsumerDisclosureDefault
     *
     * Gets the Electronic Record and Signature Disclosure for the account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ConsumerDisclosure
     */
    public function getConsumerDisclosureDefault($account_id, AccountsApi\GetConsumerDisclosureDefaultOptions $options = null)
    {
        list($response) = $this->getConsumerDisclosureDefaultWithHttpInfo($account_id, $options);
        return $response;
    }

    /**
     * Operation getConsumerDisclosureDefaultWithHttpInfo
     *
     * Gets the Electronic Record and Signature Disclosure for the account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ConsumerDisclosure, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsumerDisclosureDefaultWithHttpInfo($account_id, AccountsApi\GetConsumerDisclosureDefaultOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getConsumerDisclosureDefault');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/consumer_disclosure";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getLangCode() !== null) {
            $queryParams['langCode'] = $this->apiClient->getSerializer()->toQueryValue($options->getLangCode());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ConsumerDisclosure',
                '/v2.1/accounts/{accountId}/consumer_disclosure'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ConsumerDisclosure', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ConsumerDisclosure', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getENoteConfiguration
     *
     * Returns the configuration information for the eNote eOriginal integration.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ENoteConfiguration
     */
    public function getENoteConfiguration($account_id)
    {
        list($response) = $this->getENoteConfigurationWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getENoteConfigurationWithHttpInfo
     *
     * Returns the configuration information for the eNote eOriginal integration.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ENoteConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function getENoteConfigurationWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getENoteConfiguration');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/enote_configuration";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ENoteConfiguration',
                '/v2.1/accounts/{accountId}/settings/enote_configuration'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ENoteConfiguration', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ENoteConfiguration', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getEnvelopePurgeConfiguration
     *
     * Select envelope purge configuration.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\EnvelopePurgeConfiguration
     */
    public function getEnvelopePurgeConfiguration($account_id)
    {
        list($response) = $this->getEnvelopePurgeConfigurationWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getEnvelopePurgeConfigurationWithHttpInfo
     *
     * Select envelope purge configuration.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\EnvelopePurgeConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEnvelopePurgeConfigurationWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getEnvelopePurgeConfiguration');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/envelope_purge_configuration";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\EnvelopePurgeConfiguration',
                '/v2.1/accounts/{accountId}/settings/envelope_purge_configuration'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\EnvelopePurgeConfiguration', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\EnvelopePurgeConfiguration', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getFavoriteTemplates
     *
     * Retrieves the list of favorited templates for this caller
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\FavoriteTemplatesInfo
     */
    public function getFavoriteTemplates($account_id)
    {
        list($response) = $this->getFavoriteTemplatesWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getFavoriteTemplatesWithHttpInfo
     *
     * Retrieves the list of favorited templates for this caller
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\FavoriteTemplatesInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFavoriteTemplatesWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getFavoriteTemplates');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/favorite_templates";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\FavoriteTemplatesInfo',
                '/v2.1/accounts/{accountId}/favorite_templates'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\FavoriteTemplatesInfo', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\FavoriteTemplatesInfo', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getNotificationDefaults
     *
     * Returns default user level settings for a specified account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\NotificationDefaults
     */
    public function getNotificationDefaults($account_id)
    {
        list($response) = $this->getNotificationDefaultsWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getNotificationDefaultsWithHttpInfo
     *
     * Returns default user level settings for a specified account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\NotificationDefaults, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNotificationDefaultsWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getNotificationDefaults');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/notification_defaults";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\NotificationDefaults',
                '/v2.1/accounts/{accountId}/settings/notification_defaults'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\NotificationDefaults', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\NotificationDefaults', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPasswordRules
     *
     * Get the password rules
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountPasswordRules
     */
    public function getPasswordRules($account_id)
    {
        list($response) = $this->getPasswordRulesWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getPasswordRulesWithHttpInfo
     *
     * Get the password rules
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountPasswordRules, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPasswordRulesWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getPasswordRules');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/password_rules";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountPasswordRules',
                '/v2.1/accounts/{accountId}/settings/password_rules'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountPasswordRules', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountPasswordRules', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPasswordRules_0
     *
     * Get membership account password rules
     *
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\UserPasswordRules
     */
    public function getPasswordRules_0()
    {
        list($response) = $this->getPasswordRules_0WithHttpInfo();
        return $response;
    }

    /**
     * Operation getPasswordRules_0WithHttpInfo
     *
     * Get membership account password rules
     *
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\UserPasswordRules, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPasswordRules_0WithHttpInfo()
    {
        // parse inputs
        $resourcePath = "/v2.1/current_user/password_rules";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\UserPasswordRules',
                '/v2.1/current_user/password_rules'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\UserPasswordRules', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\UserPasswordRules', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPermissionProfile
     *
     * Returns a permissions profile in the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $permission_profile_id 
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\PermissionProfile
     */
    public function getPermissionProfile($account_id, $permission_profile_id, AccountsApi\GetPermissionProfileOptions $options = null)
    {
        list($response) = $this->getPermissionProfileWithHttpInfo($account_id, $permission_profile_id, $options);
        return $response;
    }

    /**
     * Operation getPermissionProfileWithHttpInfo
     *
     * Returns a permissions profile in the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $permission_profile_id 
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\PermissionProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPermissionProfileWithHttpInfo($account_id, $permission_profile_id, AccountsApi\GetPermissionProfileOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getPermissionProfile');
        }
        // verify the required parameter 'permission_profile_id' is set
        if ($permission_profile_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $permission_profile_id when calling getPermissionProfile');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/permission_profiles/{permissionProfileId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getInclude() !== null) {
            $queryParams['include'] = $this->apiClient->getSerializer()->toQueryValue($options->getInclude());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($permission_profile_id !== null) {
            $resourcePath = str_replace(
                "{" . "permissionProfileId" . "}",
                $this->apiClient->getSerializer()->toPathValue($permission_profile_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\PermissionProfile',
                '/v2.1/accounts/{accountId}/permission_profiles/{permissionProfileId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\PermissionProfile', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\PermissionProfile', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getProvisioning
     *
     * Retrieves the account provisioning information for the account.
     *
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ProvisioningInformation
     */
    public function getProvisioning()
    {
        list($response) = $this->getProvisioningWithHttpInfo();
        return $response;
    }

    /**
     * Operation getProvisioningWithHttpInfo
     *
     * Retrieves the account provisioning information for the account.
     *
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ProvisioningInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProvisioningWithHttpInfo()
    {
        // parse inputs
        $resourcePath = "/v2.1/accounts/provisioning";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ProvisioningInformation',
                '/v2.1/accounts/provisioning'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ProvisioningInformation', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ProvisioningInformation', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getReportInProduct
     *
     * Gets the specified report
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $id 
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ReportInProductGet
     */
    public function getReportInProduct($account_id, $id)
    {
        list($response) = $this->getReportInProductWithHttpInfo($account_id, $id);
        return $response;
    }

    /**
     * Operation getReportInProductWithHttpInfo
     *
     * Gets the specified report
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $id 
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ReportInProductGet, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportInProductWithHttpInfo($account_id, $id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getReportInProduct');
        }
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling getReportInProduct');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/reports/{id}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                $this->apiClient->getSerializer()->toPathValue($id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ReportInProductGet',
                '/v2.1/accounts/{accountId}/reports/{id}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ReportInProductGet', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ReportInProductGet', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getReportInProductList
     *
     * Gets the descriptors for all of an account's active reports (for listings)
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ReportInProductList
     */
    public function getReportInProductList($account_id)
    {
        list($response) = $this->getReportInProductListWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getReportInProductListWithHttpInfo
     *
     * Gets the descriptors for all of an account's active reports (for listings)
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ReportInProductList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReportInProductListWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getReportInProductList');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/reports";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ReportInProductList',
                '/v2.1/accounts/{accountId}/reports'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ReportInProductList', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ReportInProductList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getSupportedLanguages
     *
     * Gets list of supported languages for recipient language setting.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\SupportedLanguages
     */
    public function getSupportedLanguages($account_id)
    {
        list($response) = $this->getSupportedLanguagesWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getSupportedLanguagesWithHttpInfo
     *
     * Gets list of supported languages for recipient language setting.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\SupportedLanguages, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSupportedLanguagesWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getSupportedLanguages');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/supported_languages";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\SupportedLanguages',
                '/v2.1/accounts/{accountId}/supported_languages'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\SupportedLanguages', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\SupportedLanguages', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getWatermark
     *
     * Get watermark information.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\Watermark
     */
    public function getWatermark($account_id)
    {
        list($response) = $this->getWatermarkWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation getWatermarkWithHttpInfo
     *
     * Get watermark information.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\Watermark, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWatermarkWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getWatermark');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/watermark";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\Watermark',
                '/v2.1/accounts/{accountId}/watermark'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\Watermark', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\Watermark', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getWatermarkPreview
     *
     * Get watermark preview.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\Watermark $watermark  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\Watermark
     */
    public function getWatermarkPreview($account_id, $watermark = null)
    {
        list($response) = $this->getWatermarkPreviewWithHttpInfo($account_id, $watermark);
        return $response;
    }

    /**
     * Operation getWatermarkPreviewWithHttpInfo
     *
     * Get watermark preview.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\Watermark $watermark  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\Watermark, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWatermarkPreviewWithHttpInfo($account_id, $watermark = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling getWatermarkPreview');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/watermark/preview";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($watermark)) {
            $_tempBody = $watermark;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\Watermark',
                '/v2.1/accounts/{accountId}/watermark/preview'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\Watermark', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\Watermark', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listBrands
     *
     * Gets a list of brand profiles.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\BrandsResponse
     */
    public function listBrands($account_id, AccountsApi\ListBrandsOptions $options = null)
    {
        list($response) = $this->listBrandsWithHttpInfo($account_id, $options);
        return $response;
    }

    /**
     * Operation listBrandsWithHttpInfo
     *
     * Gets a list of brand profiles.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\BrandsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listBrandsWithHttpInfo($account_id, AccountsApi\ListBrandsOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling listBrands');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getExcludeDistributorBrand() !== null) {
            $queryParams['exclude_distributor_brand'] = $this->apiClient->getSerializer()->toQueryValue($options->getExcludeDistributorBrand());
        }
        // query params
        if ($options->getIncludeLogos() !== null) {
            $queryParams['include_logos'] = $this->apiClient->getSerializer()->toQueryValue($options->getIncludeLogos());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\BrandsResponse',
                '/v2.1/accounts/{accountId}/brands'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\BrandsResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\BrandsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listCustomFields
     *
     * Gets a list of custom fields associated with the account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\CustomFields
     */
    public function listCustomFields($account_id)
    {
        list($response) = $this->listCustomFieldsWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation listCustomFieldsWithHttpInfo
     *
     * Gets a list of custom fields associated with the account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\CustomFields, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCustomFieldsWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling listCustomFields');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/custom_fields";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\CustomFields',
                '/v2.1/accounts/{accountId}/custom_fields'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\CustomFields', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\CustomFields', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listPermissions
     *
     * Gets a list of permission profiles.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\PermissionProfileInformation
     */
    public function listPermissions($account_id, AccountsApi\ListPermissionsOptions $options = null)
    {
        list($response) = $this->listPermissionsWithHttpInfo($account_id, $options);
        return $response;
    }

    /**
     * Operation listPermissionsWithHttpInfo
     *
     * Gets a list of permission profiles.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\PermissionProfileInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPermissionsWithHttpInfo($account_id, AccountsApi\ListPermissionsOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling listPermissions');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/permission_profiles";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getInclude() !== null) {
            $queryParams['include'] = $this->apiClient->getSerializer()->toQueryValue($options->getInclude());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\PermissionProfileInformation',
                '/v2.1/accounts/{accountId}/permission_profiles'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\PermissionProfileInformation', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\PermissionProfileInformation', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listRecipientNamesByEmail
     *
     * Gets recipient names associated with an email address.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\RecipientNamesResponse
     */
    public function listRecipientNamesByEmail($account_id, AccountsApi\ListRecipientNamesByEmailOptions $options = null)
    {
        list($response) = $this->listRecipientNamesByEmailWithHttpInfo($account_id, $options);
        return $response;
    }

    /**
     * Operation listRecipientNamesByEmailWithHttpInfo
     *
     * Gets recipient names associated with an email address.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\RecipientNamesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listRecipientNamesByEmailWithHttpInfo($account_id, AccountsApi\ListRecipientNamesByEmailOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling listRecipientNamesByEmail');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/recipient_names";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getEmail() !== null) {
            $queryParams['email'] = $this->apiClient->getSerializer()->toQueryValue($options->getEmail());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\RecipientNamesResponse',
                '/v2.1/accounts/{accountId}/recipient_names'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\RecipientNamesResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\RecipientNamesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listSettings
     *
     * Gets account settings information.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSettingsInformation
     */
    public function listSettings($account_id)
    {
        list($response) = $this->listSettingsWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation listSettingsWithHttpInfo
     *
     * Gets account settings information.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSettingsInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSettingsWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling listSettings');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSettingsInformation',
                '/v2.1/accounts/{accountId}/settings'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSettingsInformation', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSettingsInformation', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listSharedAccess
     *
     * Reserved: Gets the shared item status for one or more users.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSharedAccess
     */
    public function listSharedAccess($account_id, AccountsApi\ListSharedAccessOptions $options = null)
    {
        list($response) = $this->listSharedAccessWithHttpInfo($account_id, $options);
        return $response;
    }

    /**
     * Operation listSharedAccessWithHttpInfo
     *
     * Reserved: Gets the shared item status for one or more users.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSharedAccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSharedAccessWithHttpInfo($account_id, AccountsApi\ListSharedAccessOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling listSharedAccess');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/shared_access";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getCount() !== null) {
            $queryParams['count'] = $this->apiClient->getSerializer()->toQueryValue($options->getCount());
        }
        // query params
        if ($options->getEnvelopesNotSharedUserStatus() !== null) {
            $queryParams['envelopes_not_shared_user_status'] = $this->apiClient->getSerializer()->toQueryValue($options->getEnvelopesNotSharedUserStatus());
        }
        // query params
        if ($options->getFolderIds() !== null) {
            $queryParams['folder_ids'] = $this->apiClient->getSerializer()->toQueryValue($options->getFolderIds());
        }
        // query params
        if ($options->getItemType() !== null) {
            $queryParams['item_type'] = $this->apiClient->getSerializer()->toQueryValue($options->getItemType());
        }
        // query params
        if ($options->getSearchText() !== null) {
            $queryParams['search_text'] = $this->apiClient->getSerializer()->toQueryValue($options->getSearchText());
        }
        // query params
        if ($options->getShared() !== null) {
            $queryParams['shared'] = $this->apiClient->getSerializer()->toQueryValue($options->getShared());
        }
        // query params
        if ($options->getStartPosition() !== null) {
            $queryParams['start_position'] = $this->apiClient->getSerializer()->toQueryValue($options->getStartPosition());
        }
        // query params
        if ($options->getUserIds() !== null) {
            $queryParams['user_ids'] = $this->apiClient->getSerializer()->toQueryValue($options->getUserIds());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSharedAccess',
                '/v2.1/accounts/{accountId}/shared_access'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSharedAccess', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSharedAccess', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listSignatureProviders
     *
     * Returns Account available signature providers for specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSignatureProviders
     */
    public function listSignatureProviders($account_id)
    {
        list($response) = $this->listSignatureProvidersWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation listSignatureProvidersWithHttpInfo
     *
     * Returns Account available signature providers for specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSignatureProviders, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSignatureProvidersWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling listSignatureProviders');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/signatureProviders";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSignatureProviders',
                '/v2.1/accounts/{accountId}/signatureProviders'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSignatureProviders', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSignatureProviders', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listUnsupportedFileTypes
     *
     * Gets a list of unsupported file types.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\FileTypeList
     */
    public function listUnsupportedFileTypes($account_id)
    {
        list($response) = $this->listUnsupportedFileTypesWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation listUnsupportedFileTypesWithHttpInfo
     *
     * Gets a list of unsupported file types.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\FileTypeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listUnsupportedFileTypesWithHttpInfo($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling listUnsupportedFileTypes');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/unsupported_file_types";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\FileTypeList',
                '/v2.1/accounts/{accountId}/unsupported_file_types'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\FileTypeList', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\FileTypeList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation unFavoriteTemplate
     *
     * Unfavorite a template
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\FavoriteTemplatesInfo $favorite_templates_info  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\FavoriteTemplatesInfo
     */
    public function unFavoriteTemplate($account_id, $favorite_templates_info = null)
    {
        list($response) = $this->unFavoriteTemplateWithHttpInfo($account_id, $favorite_templates_info);
        return $response;
    }

    /**
     * Operation unFavoriteTemplateWithHttpInfo
     *
     * Unfavorite a template
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\FavoriteTemplatesInfo $favorite_templates_info  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\FavoriteTemplatesInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function unFavoriteTemplateWithHttpInfo($account_id, $favorite_templates_info = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling unFavoriteTemplate');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/favorite_templates";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($favorite_templates_info)) {
            $_tempBody = $favorite_templates_info;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\FavoriteTemplatesInfo',
                '/v2.1/accounts/{accountId}/favorite_templates'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\FavoriteTemplatesInfo', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\FavoriteTemplatesInfo', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateAccountSignature
     *
     * Updates a account signature.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\AccountSignaturesInformation $account_signatures_information  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSignaturesInformation
     */
    public function updateAccountSignature($account_id, $account_signatures_information = null)
    {
        list($response) = $this->updateAccountSignatureWithHttpInfo($account_id, $account_signatures_information);
        return $response;
    }

    /**
     * Operation updateAccountSignatureWithHttpInfo
     *
     * Updates a account signature.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\AccountSignaturesInformation $account_signatures_information  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSignaturesInformation, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAccountSignatureWithHttpInfo($account_id, $account_signatures_information = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateAccountSignature');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/signatures";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($account_signatures_information)) {
            $_tempBody = $account_signatures_information;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSignaturesInformation',
                '/v2.1/accounts/{accountId}/signatures'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSignaturesInformation', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSignaturesInformation', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateAccountSignatureById
     *
     * Updates a account signature.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $signature_id The ID of the signature being accessed.
     * @param \DocuSign\eSign\Model\AccountSignatureDefinition $account_signature_definition  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSignature
     */
    public function updateAccountSignatureById($account_id, $signature_id, $account_signature_definition = null, AccountsApi\UpdateAccountSignatureByIdOptions $options = null)
    {
        list($response) = $this->updateAccountSignatureByIdWithHttpInfo($account_id, $signature_id, $account_signature_definition, $options);
        return $response;
    }

    /**
     * Operation updateAccountSignatureByIdWithHttpInfo
     *
     * Updates a account signature.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $signature_id The ID of the signature being accessed.
     * @param \DocuSign\eSign\Model\AccountSignatureDefinition $account_signature_definition  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSignature, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAccountSignatureByIdWithHttpInfo($account_id, $signature_id, $account_signature_definition = null, AccountsApi\UpdateAccountSignatureByIdOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateAccountSignatureById');
        }
        // verify the required parameter 'signature_id' is set
        if ($signature_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $signature_id when calling updateAccountSignatureById');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/signatures/{signatureId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getCloseExistingSignature() !== null) {
            $queryParams['close_existing_signature'] = $this->apiClient->getSerializer()->toQueryValue($options->getCloseExistingSignature());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($signature_id !== null) {
            $resourcePath = str_replace(
                "{" . "signatureId" . "}",
                $this->apiClient->getSerializer()->toPathValue($signature_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($account_signature_definition)) {
            $_tempBody = $account_signature_definition;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSignature',
                '/v2.1/accounts/{accountId}/signatures/{signatureId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSignature', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSignature', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateAccountSignatureImage
     *
     * Sets a signature, initials, or stamps image.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $image_type One of **signature_image** or **initials_image**.
    * @param string $signature_id The ID of the signature being accessed.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSignature
     */
    public function updateAccountSignatureImage($account_id, $image_type, $signature_id, AccountsApi\UpdateAccountSignatureImageOptions $options = null)
    {
        list($response) = $this->updateAccountSignatureImageWithHttpInfo($account_id, $image_type, $signature_id, $options);
        return $response;
    }

    /**
     * Operation updateAccountSignatureImageWithHttpInfo
     *
     * Sets a signature, initials, or stamps image.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $image_type One of **signature_image** or **initials_image**.
    * @param string $signature_id The ID of the signature being accessed.
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSignature, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAccountSignatureImageWithHttpInfo($account_id, $image_type, $signature_id, AccountsApi\UpdateAccountSignatureImageOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateAccountSignatureImage');
        }
        // verify the required parameter 'image_type' is set
        if ($image_type === null) {
            throw new \InvalidArgumentException('Missing the required parameter $image_type when calling updateAccountSignatureImage');
        }
        // verify the required parameter 'signature_id' is set
        if ($signature_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $signature_id when calling updateAccountSignatureImage');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/signatures/{signatureId}/{imageType}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['image/gif']);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getTransparentPng() !== null) {
            $queryParams['transparent_png'] = $this->apiClient->getSerializer()->toQueryValue($options->getTransparentPng());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($image_type !== null) {
            $resourcePath = str_replace(
                "{" . "imageType" . "}",
                $this->apiClient->getSerializer()->toPathValue($image_type),
                $resourcePath
            );
        }
        // path params
        if ($signature_id !== null) {
            $resourcePath = str_replace(
                "{" . "signatureId" . "}",
                $this->apiClient->getSerializer()->toPathValue($signature_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSignature',
                '/v2.1/accounts/{accountId}/signatures/{signatureId}/{imageType}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSignature', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSignature', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateAccountTabSettings
     *
     * Modifies tab settings for specified account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\TabAccountSettings $tab_account_settings  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\TabAccountSettings
     */
    public function updateAccountTabSettings($account_id, $tab_account_settings = null)
    {
        list($response) = $this->updateAccountTabSettingsWithHttpInfo($account_id, $tab_account_settings);
        return $response;
    }

    /**
     * Operation updateAccountTabSettingsWithHttpInfo
     *
     * Modifies tab settings for specified account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\TabAccountSettings $tab_account_settings  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\TabAccountSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAccountTabSettingsWithHttpInfo($account_id, $tab_account_settings = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateAccountTabSettings');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/tabs";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($tab_account_settings)) {
            $_tempBody = $tab_account_settings;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\TabAccountSettings',
                '/v2.1/accounts/{accountId}/settings/tabs'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\TabAccountSettings', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\TabAccountSettings', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateBrand
     *
     * Updates an existing brand.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
     * @param \DocuSign\eSign\Model\Brand $brand  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\Brand
     */
    public function updateBrand($account_id, $brand_id, $brand = null)
    {
        list($response) = $this->updateBrandWithHttpInfo($account_id, $brand_id, $brand);
        return $response;
    }

    /**
     * Operation updateBrandWithHttpInfo
     *
     * Updates an existing brand.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $brand_id The unique identifier of a brand.
     * @param \DocuSign\eSign\Model\Brand $brand  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\Brand, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBrandWithHttpInfo($account_id, $brand_id, $brand = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateBrand');
        }
        // verify the required parameter 'brand_id' is set
        if ($brand_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $brand_id when calling updateBrand');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands/{brandId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                "{" . "brandId" . "}",
                $this->apiClient->getSerializer()->toPathValue($brand_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($brand)) {
            $_tempBody = $brand;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\Brand',
                '/v2.1/accounts/{accountId}/brands/{brandId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\Brand', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\Brand', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateBrandLogoByType
     *
     * Put one branding logo.
     *
    * @param string $account_id The external account number (int) or account ID GUID.
    * @param string $brand_id The id of the brand.
    * @param string $logo_type The type of logo. Valid values are:  - &#x60;primary&#x60;  - &#x60;secondary&#x60;  - &#x60;email&#x60;
     * @param string $logo_file_bytes Brand logo binary Stream. Supported formats: JPG, GIF, PNG. Maximum file size: 300 KB. Recommended dimensions: 296 x 76 pixels (larger images will be resized). Changes may take up to one hour to display in all places (required)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function updateBrandLogoByType($account_id, $brand_id, $logo_type, $logo_file_bytes)
    {
        list($response) = $this->updateBrandLogoByTypeWithHttpInfo($account_id, $brand_id, $logo_type, $logo_file_bytes);
        return $response;
    }

    /**
     * Operation updateBrandLogoByTypeWithHttpInfo
     *
     * Put one branding logo.
     *
    * @param string $account_id The external account number (int) or account ID GUID.
    * @param string $brand_id The id of the brand.
    * @param string $logo_type The type of logo. Valid values are:  - &#x60;primary&#x60;  - &#x60;secondary&#x60;  - &#x60;email&#x60;
     * @param string $logo_file_bytes Brand logo binary Stream. Supported formats: JPG, GIF, PNG. Maximum file size: 300 KB. Recommended dimensions: 296 x 76 pixels (larger images will be resized). Changes may take up to one hour to display in all places (required)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBrandLogoByTypeWithHttpInfo($account_id, $brand_id, $logo_type, $logo_file_bytes)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateBrandLogoByType');
        }
        // verify the required parameter 'brand_id' is set
        if ($brand_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $brand_id when calling updateBrandLogoByType');
        }
        // verify the required parameter 'logo_type' is set
        if ($logo_type === null) {
            throw new \InvalidArgumentException('Missing the required parameter $logo_type when calling updateBrandLogoByType');
        }
        // verify the required parameter 'logo_file_bytes' is set
        if ($logo_file_bytes === null) {
            throw new \InvalidArgumentException('Missing the required parameter $logo_file_bytes when calling updateBrandLogoByType');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands/{brandId}/logos/{logoType}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['image/png']);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                "{" . "brandId" . "}",
                $this->apiClient->getSerializer()->toPathValue($brand_id),
                $resourcePath
            );
        }
        // path params
        if ($logo_type !== null) {
            $resourcePath = str_replace(
                "{" . "logoType" . "}",
                $this->apiClient->getSerializer()->toPathValue($logo_type),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($logo_file_bytes)) {
            $_tempBody = $logo_file_bytes;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/brands/{brandId}/logos/{logoType}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateBrandResourcesByContentType
     *
     * Uploads a branding resource file.
     *
    * @param string $account_id The external account number (int) or account ID GUID.
    * @param string $brand_id The id of the brand.
    * @param string $resource_content_type The type of brand resource file that you are updating. Valid values are:  - &#x60;sending&#x60; - &#x60;signing&#x60; - &#x60;email&#x60; - &#x60;signing_captive&#x60;
    * @param \SplFileObject $file_xml Brand resource XML file. (required)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\BrandResources
     */
    public function updateBrandResourcesByContentType($account_id, $brand_id, $resource_content_type, $file_xml)
    {
        list($response) = $this->updateBrandResourcesByContentTypeWithHttpInfo($account_id, $brand_id, $resource_content_type, $file_xml);
        return $response;
    }

    /**
     * Operation updateBrandResourcesByContentTypeWithHttpInfo
     *
     * Uploads a branding resource file.
     *
    * @param string $account_id The external account number (int) or account ID GUID.
    * @param string $brand_id The id of the brand.
    * @param string $resource_content_type The type of brand resource file that you are updating. Valid values are:  - &#x60;sending&#x60; - &#x60;signing&#x60; - &#x60;email&#x60; - &#x60;signing_captive&#x60;
    * @param \SplFileObject $file_xml Brand resource XML file. (required)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\BrandResources, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBrandResourcesByContentTypeWithHttpInfo($account_id, $brand_id, $resource_content_type, $file_xml)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateBrandResourcesByContentType');
        }
        // verify the required parameter 'brand_id' is set
        if ($brand_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $brand_id when calling updateBrandResourcesByContentType');
        }
        // verify the required parameter 'resource_content_type' is set
        if ($resource_content_type === null) {
            throw new \InvalidArgumentException('Missing the required parameter $resource_content_type when calling updateBrandResourcesByContentType');
        }
        // verify the required parameter 'file_xml' is set
        if ($file_xml === null) {
            throw new \InvalidArgumentException('Missing the required parameter $file_xml when calling updateBrandResourcesByContentType');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/brands/{brandId}/resources/{resourceContentType}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['multipart/form-data']);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($brand_id !== null) {
            $resourcePath = str_replace(
                "{" . "brandId" . "}",
                $this->apiClient->getSerializer()->toPathValue($brand_id),
                $resourcePath
            );
        }
        // path params
        if ($resource_content_type !== null) {
            $resourcePath = str_replace(
                "{" . "resourceContentType" . "}",
                $this->apiClient->getSerializer()->toPathValue($resource_content_type),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // form params
        if ($file_xml !== null) {
            // PHP 5.5 introduced a CurlFile object that deprecates the old @filename syntax
            // See: https://wiki.php.net/rfc/curl-file-upload
            if (function_exists('curl_file_create')) {
                $formParams['file.xml'] = curl_file_create($this->apiClient->getSerializer()->toFormValue($file_xml));
            } else {
                $formParams['file.xml'] = '@' . $this->apiClient->getSerializer()->toFormValue($file_xml);
            }
        }
        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\BrandResources',
                '/v2.1/accounts/{accountId}/brands/{brandId}/resources/{resourceContentType}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\BrandResources', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\BrandResources', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateConsumerDisclosure
     *
     * Update Consumer Disclosure.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $lang_code The simple type enumeration the language used in the response. The supported languages, with the language value shown in parenthesis, are:Arabic (ar), Armenian (hy), Bulgarian (bg), Czech (cs), Chinese Simplified (zh_CN), Chinese Traditional (zh_TW), Croatian (hr), Danish (da), Dutch (nl), English US (en), English UK (en_GB), Estonian (et), Farsi (fa), Finnish (fi), French (fr), French Canada (fr_CA), German (de), Greek (el), Hebrew (he), Hindi (hi), Hungarian (hu), Bahasa Indonesia (id), Italian (it), Japanese (ja), Korean (ko), Latvian (lv), Lithuanian (lt), Bahasa Melayu (ms), Norwegian (no), Polish (pl), Portuguese (pt), Portuguese Brazil (pt_BR), Romanian (ro), Russian (ru), Serbian (sr), Slovak (sk), Slovenian (sl), Spanish (es),Spanish Latin America (es_MX), Swedish (sv), Thai (th), Turkish (tr), Ukrainian (uk) and Vietnamese (vi). Additionally, the value can be set to Ã¯Â¿Â½browserÃ¯Â¿Â½ to automatically detect the browser language being used by the viewer and display the disclosure in that language.
     * @param \DocuSign\eSign\Model\ConsumerDisclosure $consumer_disclosure  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ConsumerDisclosure
     */
    public function updateConsumerDisclosure($account_id, $lang_code, $consumer_disclosure = null, AccountsApi\UpdateConsumerDisclosureOptions $options = null)
    {
        list($response) = $this->updateConsumerDisclosureWithHttpInfo($account_id, $lang_code, $consumer_disclosure, $options);
        return $response;
    }

    /**
     * Operation updateConsumerDisclosureWithHttpInfo
     *
     * Update Consumer Disclosure.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $lang_code The simple type enumeration the language used in the response. The supported languages, with the language value shown in parenthesis, are:Arabic (ar), Armenian (hy), Bulgarian (bg), Czech (cs), Chinese Simplified (zh_CN), Chinese Traditional (zh_TW), Croatian (hr), Danish (da), Dutch (nl), English US (en), English UK (en_GB), Estonian (et), Farsi (fa), Finnish (fi), French (fr), French Canada (fr_CA), German (de), Greek (el), Hebrew (he), Hindi (hi), Hungarian (hu), Bahasa Indonesia (id), Italian (it), Japanese (ja), Korean (ko), Latvian (lv), Lithuanian (lt), Bahasa Melayu (ms), Norwegian (no), Polish (pl), Portuguese (pt), Portuguese Brazil (pt_BR), Romanian (ro), Russian (ru), Serbian (sr), Slovak (sk), Slovenian (sl), Spanish (es),Spanish Latin America (es_MX), Swedish (sv), Thai (th), Turkish (tr), Ukrainian (uk) and Vietnamese (vi). Additionally, the value can be set to Ã¯Â¿Â½browserÃ¯Â¿Â½ to automatically detect the browser language being used by the viewer and display the disclosure in that language.
     * @param \DocuSign\eSign\Model\ConsumerDisclosure $consumer_disclosure  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ConsumerDisclosure, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConsumerDisclosureWithHttpInfo($account_id, $lang_code, $consumer_disclosure = null, AccountsApi\UpdateConsumerDisclosureOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateConsumerDisclosure');
        }
        // verify the required parameter 'lang_code' is set
        if ($lang_code === null) {
            throw new \InvalidArgumentException('Missing the required parameter $lang_code when calling updateConsumerDisclosure');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/consumer_disclosure/{langCode}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getIncludeMetadata() !== null) {
            $queryParams['include_metadata'] = $this->apiClient->getSerializer()->toQueryValue($options->getIncludeMetadata());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($lang_code !== null) {
            $resourcePath = str_replace(
                "{" . "langCode" . "}",
                $this->apiClient->getSerializer()->toPathValue($lang_code),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($consumer_disclosure)) {
            $_tempBody = $consumer_disclosure;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ConsumerDisclosure',
                '/v2.1/accounts/{accountId}/consumer_disclosure/{langCode}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ConsumerDisclosure', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ConsumerDisclosure', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateCustomField
     *
     * Updates an existing account custom field.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $custom_field_id 
     * @param \DocuSign\eSign\Model\CustomField $custom_field  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\CustomFields
     */
    public function updateCustomField($account_id, $custom_field_id, $custom_field = null, AccountsApi\UpdateCustomFieldOptions $options = null)
    {
        list($response) = $this->updateCustomFieldWithHttpInfo($account_id, $custom_field_id, $custom_field, $options);
        return $response;
    }

    /**
     * Operation updateCustomFieldWithHttpInfo
     *
     * Updates an existing account custom field.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $custom_field_id 
     * @param \DocuSign\eSign\Model\CustomField $custom_field  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\CustomFields, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCustomFieldWithHttpInfo($account_id, $custom_field_id, $custom_field = null, AccountsApi\UpdateCustomFieldOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateCustomField');
        }
        // verify the required parameter 'custom_field_id' is set
        if ($custom_field_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $custom_field_id when calling updateCustomField');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/custom_fields/{customFieldId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getApplyToTemplates() !== null) {
            $queryParams['apply_to_templates'] = $this->apiClient->getSerializer()->toQueryValue($options->getApplyToTemplates());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($custom_field_id !== null) {
            $resourcePath = str_replace(
                "{" . "customFieldId" . "}",
                $this->apiClient->getSerializer()->toPathValue($custom_field_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($custom_field)) {
            $_tempBody = $custom_field;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\CustomFields',
                '/v2.1/accounts/{accountId}/custom_fields/{customFieldId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\CustomFields', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\CustomFields', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateENoteConfiguration
     *
     * Updates configuration information for the eNote eOriginal integration.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\ENoteConfiguration $e_note_configuration  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ENoteConfiguration
     */
    public function updateENoteConfiguration($account_id, $e_note_configuration = null)
    {
        list($response) = $this->updateENoteConfigurationWithHttpInfo($account_id, $e_note_configuration);
        return $response;
    }

    /**
     * Operation updateENoteConfigurationWithHttpInfo
     *
     * Updates configuration information for the eNote eOriginal integration.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\ENoteConfiguration $e_note_configuration  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ENoteConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateENoteConfigurationWithHttpInfo($account_id, $e_note_configuration = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateENoteConfiguration');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/enote_configuration";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($e_note_configuration)) {
            $_tempBody = $e_note_configuration;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ENoteConfiguration',
                '/v2.1/accounts/{accountId}/settings/enote_configuration'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ENoteConfiguration', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ENoteConfiguration', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateEnvelopePurgeConfiguration
     *
     * Updates envelope purge configuration.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\EnvelopePurgeConfiguration $envelope_purge_configuration  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\EnvelopePurgeConfiguration
     */
    public function updateEnvelopePurgeConfiguration($account_id, $envelope_purge_configuration = null)
    {
        list($response) = $this->updateEnvelopePurgeConfigurationWithHttpInfo($account_id, $envelope_purge_configuration);
        return $response;
    }

    /**
     * Operation updateEnvelopePurgeConfigurationWithHttpInfo
     *
     * Updates envelope purge configuration.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\EnvelopePurgeConfiguration $envelope_purge_configuration  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\EnvelopePurgeConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEnvelopePurgeConfigurationWithHttpInfo($account_id, $envelope_purge_configuration = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateEnvelopePurgeConfiguration');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/envelope_purge_configuration";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($envelope_purge_configuration)) {
            $_tempBody = $envelope_purge_configuration;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\EnvelopePurgeConfiguration',
                '/v2.1/accounts/{accountId}/settings/envelope_purge_configuration'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\EnvelopePurgeConfiguration', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\EnvelopePurgeConfiguration', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateFavoriteTemplate
     *
     * Favorites a template
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\FavoriteTemplatesInfo $favorite_templates_info  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\FavoriteTemplatesInfo
     */
    public function updateFavoriteTemplate($account_id, $favorite_templates_info = null)
    {
        list($response) = $this->updateFavoriteTemplateWithHttpInfo($account_id, $favorite_templates_info);
        return $response;
    }

    /**
     * Operation updateFavoriteTemplateWithHttpInfo
     *
     * Favorites a template
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\FavoriteTemplatesInfo $favorite_templates_info  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\FavoriteTemplatesInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFavoriteTemplateWithHttpInfo($account_id, $favorite_templates_info = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateFavoriteTemplate');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/favorite_templates";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($favorite_templates_info)) {
            $_tempBody = $favorite_templates_info;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\FavoriteTemplatesInfo',
                '/v2.1/accounts/{accountId}/favorite_templates'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\FavoriteTemplatesInfo', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\FavoriteTemplatesInfo', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateNotificationDefaults
     *
     * Updates default user level settings for a specified account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\NotificationDefaults $notification_defaults  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\NotificationDefaults
     */
    public function updateNotificationDefaults($account_id, $notification_defaults = null)
    {
        list($response) = $this->updateNotificationDefaultsWithHttpInfo($account_id, $notification_defaults);
        return $response;
    }

    /**
     * Operation updateNotificationDefaultsWithHttpInfo
     *
     * Updates default user level settings for a specified account
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\NotificationDefaults $notification_defaults  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\NotificationDefaults, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNotificationDefaultsWithHttpInfo($account_id, $notification_defaults = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateNotificationDefaults');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/notification_defaults";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($notification_defaults)) {
            $_tempBody = $notification_defaults;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\NotificationDefaults',
                '/v2.1/accounts/{accountId}/settings/notification_defaults'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\NotificationDefaults', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\NotificationDefaults', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updatePasswordRules
     *
     * Update the password rules
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\AccountPasswordRules $account_password_rules  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountPasswordRules
     */
    public function updatePasswordRules($account_id, $account_password_rules = null)
    {
        list($response) = $this->updatePasswordRulesWithHttpInfo($account_id, $account_password_rules);
        return $response;
    }

    /**
     * Operation updatePasswordRulesWithHttpInfo
     *
     * Update the password rules
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\AccountPasswordRules $account_password_rules  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountPasswordRules, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePasswordRulesWithHttpInfo($account_id, $account_password_rules = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updatePasswordRules');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings/password_rules";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($account_password_rules)) {
            $_tempBody = $account_password_rules;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountPasswordRules',
                '/v2.1/accounts/{accountId}/settings/password_rules'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountPasswordRules', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountPasswordRules', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updatePermissionProfile
     *
     * Updates a permission profile within the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $permission_profile_id 
     * @param \DocuSign\eSign\Model\PermissionProfile $permission_profile  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\PermissionProfile
     */
    public function updatePermissionProfile($account_id, $permission_profile_id, $permission_profile = null, AccountsApi\UpdatePermissionProfileOptions $options = null)
    {
        list($response) = $this->updatePermissionProfileWithHttpInfo($account_id, $permission_profile_id, $permission_profile, $options);
        return $response;
    }

    /**
     * Operation updatePermissionProfileWithHttpInfo
     *
     * Updates a permission profile within the specified account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $permission_profile_id 
     * @param \DocuSign\eSign\Model\PermissionProfile $permission_profile  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\PermissionProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePermissionProfileWithHttpInfo($account_id, $permission_profile_id, $permission_profile = null, AccountsApi\UpdatePermissionProfileOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updatePermissionProfile');
        }
        // verify the required parameter 'permission_profile_id' is set
        if ($permission_profile_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $permission_profile_id when calling updatePermissionProfile');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/permission_profiles/{permissionProfileId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getInclude() !== null) {
            $queryParams['include'] = $this->apiClient->getSerializer()->toQueryValue($options->getInclude());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($permission_profile_id !== null) {
            $resourcePath = str_replace(
                "{" . "permissionProfileId" . "}",
                $this->apiClient->getSerializer()->toPathValue($permission_profile_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($permission_profile)) {
            $_tempBody = $permission_profile;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\PermissionProfile',
                '/v2.1/accounts/{accountId}/permission_profiles/{permissionProfileId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\PermissionProfile', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\PermissionProfile', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateReportInProductRunResults
     *
     * Returns the result set from running the specified report
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\ReportInProductRunRequest $report_in_product_run_request  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ReportInProductRunResponse
     */
    public function updateReportInProductRunResults($account_id, $report_in_product_run_request = null)
    {
        list($response) = $this->updateReportInProductRunResultsWithHttpInfo($account_id, $report_in_product_run_request);
        return $response;
    }

    /**
     * Operation updateReportInProductRunResultsWithHttpInfo
     *
     * Returns the result set from running the specified report
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\ReportInProductRunRequest $report_in_product_run_request  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ReportInProductRunResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateReportInProductRunResultsWithHttpInfo($account_id, $report_in_product_run_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateReportInProductRunResults');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/reports/report_results";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($report_in_product_run_request)) {
            $_tempBody = $report_in_product_run_request;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ReportInProductRunResponse',
                '/v2.1/accounts/{accountId}/reports/report_results'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ReportInProductRunResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ReportInProductRunResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateReportInProductSave
     *
     * Saves a customized report
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $id 
     * @param \DocuSign\eSign\Model\ReportInProductRunRequest $report_in_product_run_request  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\ReportInProductSaveResponse
     */
    public function updateReportInProductSave($account_id, $id, $report_in_product_run_request = null)
    {
        list($response) = $this->updateReportInProductSaveWithHttpInfo($account_id, $id, $report_in_product_run_request);
        return $response;
    }

    /**
     * Operation updateReportInProductSaveWithHttpInfo
     *
     * Saves a customized report
     *
    * @param string $account_id The external account number (int) or account ID Guid.
    * @param string $id 
     * @param \DocuSign\eSign\Model\ReportInProductRunRequest $report_in_product_run_request  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\ReportInProductSaveResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateReportInProductSaveWithHttpInfo($account_id, $id, $report_in_product_run_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateReportInProductSave');
        }
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling updateReportInProductSave');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/reports/{id}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                $this->apiClient->getSerializer()->toPathValue($id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($report_in_product_run_request)) {
            $_tempBody = $report_in_product_run_request;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\ReportInProductSaveResponse',
                '/v2.1/accounts/{accountId}/reports/{id}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\ReportInProductSaveResponse', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ReportInProductSaveResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateReportResultsCsv
     *
     * Returns the specified report as a CSV string
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\ReportInProductCsvRunRequest $report_in_product_csv_run_request  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function updateReportResultsCsv($account_id, $report_in_product_csv_run_request = null)
    {
        list($response) = $this->updateReportResultsCsvWithHttpInfo($account_id, $report_in_product_csv_run_request);
        return $response;
    }

    /**
     * Operation updateReportResultsCsvWithHttpInfo
     *
     * Returns the specified report as a CSV string
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\ReportInProductCsvRunRequest $report_in_product_csv_run_request  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateReportResultsCsvWithHttpInfo($account_id, $report_in_product_csv_run_request = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateReportResultsCsv');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/reports/report_results_csv";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($report_in_product_csv_run_request)) {
            $_tempBody = $report_in_product_csv_run_request;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/reports/report_results_csv'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateSettings
     *
     * Updates the account settings for an account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\AccountSettingsInformation $account_settings_information  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return void
     */
    public function updateSettings($account_id, $account_settings_information = null)
    {
        list($response) = $this->updateSettingsWithHttpInfo($account_id, $account_settings_information);
        return $response;
    }

    /**
     * Operation updateSettingsWithHttpInfo
     *
     * Updates the account settings for an account.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\AccountSettingsInformation $account_settings_information  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSettingsWithHttpInfo($account_id, $account_settings_information = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateSettings');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/settings";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($account_settings_information)) {
            $_tempBody = $account_settings_information;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/v2.1/accounts/{accountId}/settings'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateSharedAccess
     *
     * Reserved: Sets the shared access information for users.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\AccountSharedAccess $account_shared_access  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\AccountSharedAccess
     */
    public function updateSharedAccess($account_id, $account_shared_access = null, AccountsApi\UpdateSharedAccessOptions $options = null)
    {
        list($response) = $this->updateSharedAccessWithHttpInfo($account_id, $account_shared_access, $options);
        return $response;
    }

    /**
     * Operation updateSharedAccessWithHttpInfo
     *
     * Reserved: Sets the shared access information for users.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\AccountSharedAccess $account_shared_access  (optional)
     * @param  $options Options for modifying the behavior of the function. (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\AccountSharedAccess, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSharedAccessWithHttpInfo($account_id, $account_shared_access = null, AccountsApi\UpdateSharedAccessOptions $options = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateSharedAccess');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/shared_access";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        if ($options != null)
        {
        // query params
        // query params
        if ($options->getItemType() !== null) {
            $queryParams['item_type'] = $this->apiClient->getSerializer()->toQueryValue($options->getItemType());
        }
        // query params
        if ($options->getPreserveExistingSharedAccess() !== null) {
            $queryParams['preserve_existing_shared_access'] = $this->apiClient->getSerializer()->toQueryValue($options->getPreserveExistingSharedAccess());
        }
        // query params
        if ($options->getUserIds() !== null) {
            $queryParams['user_ids'] = $this->apiClient->getSerializer()->toQueryValue($options->getUserIds());
        }
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($account_shared_access)) {
            $_tempBody = $account_shared_access;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\AccountSharedAccess',
                '/v2.1/accounts/{accountId}/shared_access'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\AccountSharedAccess', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\AccountSharedAccess', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateWatermark
     *
     * Update watermark information.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\Watermark $watermark  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return \DocuSign\eSign\Model\Watermark
     */
    public function updateWatermark($account_id, $watermark = null)
    {
        list($response) = $this->updateWatermarkWithHttpInfo($account_id, $watermark);
        return $response;
    }

    /**
     * Operation updateWatermarkWithHttpInfo
     *
     * Update watermark information.
     *
    * @param string $account_id The external account number (int) or account ID Guid.
     * @param \DocuSign\eSign\Model\Watermark $watermark  (optional)
     * @throws \DocuSign\eSign\Client\ApiException on non-2xx response
     * @return array of \DocuSign\eSign\Model\Watermark, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateWatermarkWithHttpInfo($account_id, $watermark = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $account_id when calling updateWatermark');
        }
        // parse inputs
        $resourcePath = "/v2.1/accounts/{accountId}/watermark";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                "{" . "accountId" . "}",
                $this->apiClient->getSerializer()->toPathValue($account_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($watermark)) {
            $_tempBody = $watermark;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires OAuth (access token)
        if (strlen($this->apiClient->getConfig()->getAccessToken()) !== 0) {
            $headerParams['Authorization'] = 'Bearer ' . $this->apiClient->getConfig()->getAccessToken();
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                '\DocuSign\eSign\Model\Watermark',
                '/v2.1/accounts/{accountId}/watermark'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\DocuSign\eSign\Model\Watermark', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\Watermark', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\DocuSign\eSign\Model\ErrorDetails', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
}
